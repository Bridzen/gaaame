<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Grand Bosnia: Vertical Limit</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        #hud {
            position: absolute; top: 20px; left: 20px;
            color: #fff; background: rgba(0, 20, 30, 0.6);
            padding: 20px; border-radius: 8px; border-left: 4px solid #00ddee;
            font-size: 14px; pointer-events: none; backdrop-filter: blur(8px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 240px;
            z-index: 20;
        }
        
        .stat-label { font-size: 10px; opacity: 0.7; letter-spacing: 2px; text-transform: uppercase; }
        .stat-val { font-size: 18px; font-weight: 900; color: #fff; float: right; }
        .biome-tag { color: #00ddee; text-shadow: 0 0 10px rgba(0, 221, 238, 0.5); }
        .danger { color: #ff3333; text-shadow: 0 0 10px #ff0000; }
        .climb { color: #ffaa00; text-shadow: 0 0 10px #ffaa00; }
        .gear-active { color: #55ff55; text-shadow: 0 0 10px #00ff00; }
        
        .bar-container {
            width: 100%; height: 6px;
            background: #112211; border-radius: 3px; overflow: hidden; margin-top: 5px;
        }
        #health-bar {
            width: 100%; height: 100%; background: #ff3333;
            box-shadow: 0 0 10px #ff3333; transition: width 0.1s;
        }
        #stamina-bar {
            width: 100%; height: 100%; background: #00ddee;
            box-shadow: 0 0 10px #00ddee; transition: width 0.1s;
        }

        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
            display: none; pointer-events: none; z-index: 10;
        }
        
        #pickup-msg {
            position: absolute; bottom: 120px; width: 100%; text-align: center;
            color: #fff; font-weight: bold; font-size: 24px; text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }

        #interaction-prompt {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            color: #ffff00; font-weight: 900; font-size: 20px; letter-spacing: 2px;
            text-shadow: 0 0 10px #000; display: none; pointer-events: none; z-index: 100;
            text-align: center;
        }

        #craft-prompt {
            position: absolute; bottom: 80px; width: 100%; text-align: center;
            color: #ffff00; font-weight: 900; font-size: 18px; letter-spacing: 2px;
            text-shadow: 0 0 10px #ffff00; display: none; pointer-events: none;
        }

        #crafting-menu {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 400px; padding: 30px; background: rgba(10, 20, 30, 0.95);
            border: 2px solid #00ddee; border-radius: 10px; box-shadow: 0 0 50px rgba(0, 221, 238, 0.2);
            color: #fff; text-align: center; display: none; z-index: 100;
        }
        #crafting-menu h2 { margin-top: 0; color: #00ddee; text-transform: uppercase; letter-spacing: 3px; }
        .craft-item { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 5px; margin-top: 20px; }
        .craft-btn {
            background: #00ddee; color: #000; border: none; padding: 10px 20px;
            font-weight: bold; font-size: 16px; cursor: pointer; margin-top: 10px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .craft-btn:hover { background: #fff; box-shadow: 0 0 15px #fff; }

        #controls {
            position: absolute; bottom: 30px; left: 30px;
            color: rgba(255,255,255,0.5); font-weight: 600; 
            text-transform: uppercase; letter-spacing: 1px; font-size: 12px;
            pointer-events: none;
        }

        #mobile-look {
            position: absolute; bottom: 40px; right: 30px;
            display: flex; flex-direction: column; gap: 10px;
            z-index: 50;
        }
        .look-btn {
            width: 60px; height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: white; font-size: 24px; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; backdrop-filter: blur(4px);
            user-select: none;
        }
        .look-btn:active { background: rgba(0, 221, 238, 0.4); border-color: #00ddee; }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: #fff; opacity: 0.5;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #000000 0%, #1a2a3a 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 99; cursor: pointer;
        }
        #game-over-screen { background: rgba(50, 0, 0, 0.9); display: none; z-index: 150; }
        
        .btn { 
            background: transparent; color: #00ddee; padding: 15px 50px; 
            margin-top: 30px; font-weight: 800; letter-spacing: 3px;
            font-size: 18px; border: 2px solid #00ddee; border-radius: 30px;
            transition: 0.2s; box-shadow: 0 0 15px rgba(0, 221, 238, 0.2);
        }
        .btn:hover { background: #00ddee; color: #000; box-shadow: 0 0 35px rgba(0, 221, 238, 0.6); }
        
        #loading { font-size: 12px; margin-top: 15px; color: #888; display:none; font-family: monospace; }
        #error-box { position: absolute; top: 10px; right: 10px; width: 300px; background: #500; color: #fff; padding: 10px; display: none; font-family: monospace; z-index: 100; border: 1px solid #f00; }
        #time-disp { position: absolute; top: 20px; right: 20px; color: #fff; font-weight: bold; font-family: monospace; font-size: 16px; opacity: 0.8; }
    </style>
    
    <script>
        var startGame = function() {
            alert("Game assets are still loading... Please wait 5 seconds and click again!");
        };
        var restartGame = function() {
            location.reload();
        };
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="error-box"></div>
    <div id="crosshair"></div>
    <div id="damage-overlay"></div>
    <div id="pickup-msg">Stick Found</div>
    <div id="interaction-prompt"></div>
    <div id="craft-prompt">STICKS COLLECTED! PRESS 'C' TO CRAFT</div>
    <div id="time-disp">12:00</div>

    <div id="crafting-menu">
        <h2>Fabricator</h2>
        <div class="craft-item">
            <h3>Hiking Sticks</h3>
            <p style="font-size:12px; opacity:0.7">Reinforced nanocarbon sticks. Increases climb slope to 360%.</p>
            <p style="color:#ffff00; font-size:12px;">COST: 2 STICKS</p>
            <button class="craft-btn" onclick="craftHikingSticks()">CRAFT</button>
        </div>
        <div style="margin-top:20px; font-size:10px; opacity:0.5; cursor:pointer;" onclick="closeCrafting()">[CLOSE]</div>
    </div>

    <div id="start-screen">
        <h1 style="font-size:60px; margin-bottom:0px; letter-spacing: 5px; color: #fff;">PLANET BOSNIA</h1>
        <p style="font-size:16px; opacity:0.6; letter-spacing: 4px; text-transform:uppercase;">Rider Update</p>
        <div class="btn" onclick="startGame()">INITIATE LANDING</div>
        <div id="loading">Generating Ecosystem...</div>
    </div>

    <div id="game-over-screen">
        <h1 style="font-size:60px; color: #ff3333; letter-spacing: 5px;">YOU DIED</h1>
        <p style="color: #fff;">The wilderness has claimed you.</p>
        <div class="btn" style="border-color:#ff3333; color:#ff3333;" onclick="restartGame()">RESPAWN</div>
    </div>

    <div id="hud">
        <div style="border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px; margin-bottom:10px;">
            <span class="stat-label">BIOME</span><br>
            <span id="biome-disp" class="stat-val biome-tag" style="float:none; font-size: 20px;">UNKNOWN</span>
        </div>
        <div>
            <span class="stat-label">ALTITUDE</span>
            <span id="alt-disp" class="stat-val">0m</span>
        </div>
        <div style="clear:both; padding-top:5px;">
            <span class="stat-label">SLOPE</span>
            <span id="slope-disp" class="stat-val">0%</span>
        </div>
        
        <div style="margin-top:20px">
            <span class="stat-label">SUIT INTEGRITY</span>
            <div class="bar-container">
                <div id="health-bar"></div>
            </div>
            <span class="stat-label" style="display:block; margin-top:5px;">STAMINA</span>
            <div class="bar-container">
                <div id="stamina-bar"></div>
            </div>
        </div>

        <div style="margin-top:20px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
            <span class="stat-label">INVENTORY</span><br>
            <div style="margin-top:5px;">
                <span style="opacity:0.7">STICKS:</span> <span id="stick-count" style="float:right; font-weight:bold;">0/2</span>
            </div>
            <div style="margin-top:5px;">
                <span style="opacity:0.7">GRASS:</span> <span id="grass-count" style="float:right; font-weight:bold; color:#55ff55">0</span>
            </div>
            <div style="margin-top:5px;">
                <span style="opacity:0.7">GEAR:</span> <span id="gear-disp" style="float:right; font-weight:bold; color:#888;">NONE</span>
            </div>
        </div>
    </div>
    
    <div id="mobile-look">
        <div class="look-btn" id="btn-up">▲</div>
        <div class="look-btn" id="btn-down">▼</div>
    </div>

    <div id="controls">
        WASD Move // SHIFT Run // E Interact // C Craft
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        window.onerror = function(msg, url, lineNo, columnNo, error) {
            const box = document.getElementById('error-box');
            box.style.display = 'block';
            box.innerHTML = `<strong>ERROR:</strong><br>${msg}<br><small>${url}:${lineNo}</small>`;
            return false;
        };

        // --- CONFIG ---
        const WORLD_SIZE = 30000; 
        const RES = 150; 
        const SEGMENT_SIZE = WORLD_SIZE / RES;
        const SEED_X = Math.random() * 10000;
        const SEED_Z = Math.random() * 10000;
        
        // --- SCENE & ATMOSPHERE ---
        let gameActive = false;
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const fog = new THREE.FogExp2(0xaaccff, 0.00025);
        scene.fog = fog;

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 40000); 
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", depth: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap; 
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3; 
        document.body.appendChild(renderer.domElement);

        // --- PARTICLES ---
        const particlesGeo = new THREE.BufferGeometry();
        const particlesCount = 4000; 
        const pArray = new Float32Array(particlesCount * 3);
        for(let i=0; i<particlesCount*3; i++) {
            pArray[i] = (Math.random() - 0.5) * 200; 
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pArray, 3));
        const particlesMat = new THREE.PointsMaterial({
            size: 0.15, color: 0xffffff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending
        });
        const particles = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particles);

        // --- STARS ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 6000;
        const starArr = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starArr[i] = (Math.random() - 0.5) * 12000;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starArr, 3));
        const starMat = new THREE.PointsMaterial({ size: 2.0, color: 0xffffff, sizeAttenuation: false, transparent: true, opacity: 0 });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- POST PROCESSING ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.6; bloomPass.strength = 0.4; bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.25); 
        scene.add(hemiLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffee, 1.5); 
        sunLight.castShadow = true;
        sunLight.shadow.camera.far = 25000;
        sunLight.shadow.mapSize.set(1024, 1024);
        const d = 4000;
        sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        scene.add(sunLight);

        const sunSphere = new THREE.Mesh(new THREE.SphereGeometry(400, 16, 16), new THREE.MeshBasicMaterial({color: 0xffaa33}));
        scene.add(sunSphere);

        // --- NOISE ---
        const p = new Uint8Array(512);
        const perm = new Uint8Array(512);
        for(let i=0; i<256; i++) p[i] = i;
        for(let i=0; i<256; i++) {
            let r = i + ~~(Math.random() * (256 - i));
            let t = p[i]; p[i] = p[r]; p[r] = t;
        }
        for(let i=0; i<512; i++) perm[i] = p[i & 255];
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        function noise(x, y) {
            const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
            x -= Math.floor(x); y -= Math.floor(y);
            const u = fade(x), v = fade(y);
            const A = perm[X] + Y, B = perm[X + 1] + Y;
            return lerp(v, lerp(u, grad(perm[A], x, y), grad(perm[B], x - 1, y)),
                                lerp(u, grad(perm[A + 1], x, y - 1), grad(perm[B + 1], x - 1, y - 1)));
        }

        // --- TERRAIN ---
        const geo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, RES, RES);
        geo.rotateX(-Math.PI / 2);
        const count = geo.attributes.position.count;
        geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
        const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9, metalness: 0.1, flatShading: true });
        const terrain = new THREE.Mesh(geo, mat);
        terrain.receiveShadow = true;

        function getBiomeData(x, z, height) {
            const moisture = noise(x * 0.0003, z * 0.0003); 
            if (height < 300) {
                if (moisture > 0.2) return { type: 'FOREST', r: 0.1, g: 0.35, b: 0.1 }; 
                return { type: 'GRASSLAND', r: 0.3, g: 0.6, b: 0.15 }; 
            } else if (height < 2500) {
                if (moisture > 0.4) return { type: 'HIGHLANDS', r: 0.25, g: 0.45, b: 0.25 }; 
                return { type: 'ROCKY_SLOPES', r: 0.5, g: 0.45, b: 0.4 }; 
            } else if (height < 5000) {
                return { type: 'MOUNTAIN', r: 0.4, g: 0.4, b: 0.45 }; 
            } else {
                return { type: 'SNOW', r: 0.95, g: 0.95, b: 1.0 }; 
            }
        }

        function getRawHeight(x, z) {
            const nx = x + SEED_X;
            const nz = z + SEED_Z;
            let biome = noise(nx * 0.00015, nz * 0.00015);
            
            let height = noise(nx * 0.001, nz * 0.001) * 150;
            height += noise(nx * 0.005, nz * 0.005) * 30;
            
            if (biome > -0.1) { 
                let mtnHeight = Math.abs(noise(nx * 0.0004, nz * 0.0004)) * 6000;
                mtnHeight += noise(nx * 0.002, nz * 0.002) * 500;
                const terraceSize = 150; 
                let shelf = Math.sin(mtnHeight / terraceSize);
                if (shelf > 0.5) mtnHeight -= (shelf - 0.5) * 30; 
                let blend = (biome + 0.1) * 3; if (blend > 1) blend = 1;
                height = lerp(blend, height, mtnHeight);
            }
            
            if (biome > 0.4) {
                let titanBase = (biome - 0.4) * 2.0; if (titanBase > 1) titanBase = 1;
                let titanHeight = Math.pow(Math.abs(noise(nx * 0.0002, nz * 0.0002)), 2.0) * 25000; 
                titanHeight += Math.abs(noise(nx * 0.001, nz * 0.001)) * 2000;
                height = lerp(titanBase, height, titanHeight);
            }
            
            const dist = Math.sqrt(x*x + z*z);
            let sm = 1.0;
            if (dist < 400) sm = 0.0; 
            else if (dist < 1000) sm = (dist - 400) / 600;
            
            height *= sm; 
            if(height < -20) height = -20;
            return height;
        }

        function getMeshHeight(x, z) {
            const gridX = Math.floor((x + WORLD_SIZE/2) / SEGMENT_SIZE);
            const gridZ = Math.floor((z + WORLD_SIZE/2) / SEGMENT_SIZE);
            const x0 = (gridX * SEGMENT_SIZE) - WORLD_SIZE/2;
            const z0 = (gridZ * SEGMENT_SIZE) - WORLD_SIZE/2;
            const x1 = x0 + SEGMENT_SIZE;
            const z1 = z0 + SEGMENT_SIZE;
            const u = (x - x0) / SEGMENT_SIZE;
            const v = (z - z0) / SEGMENT_SIZE;
            const h00 = getRawHeight(x0, z0);
            const h10 = getRawHeight(x1, z0);
            const h01 = getRawHeight(x0, z1);
            const h11 = getRawHeight(x1, z1);
            if (u + v < 1) return h00 + (h10 - h00) * u + (h01 - h00) * v;
            else return h11 + (h01 - h11) * (1 - u) + (h10 - h11) * (1 - v);
        }

        const vecA = new THREE.Vector3(), vecB = new THREE.Vector3(), vecC = new THREE.Vector3();
        const sub1 = new THREE.Vector3(), sub2 = new THREE.Vector3();
        function getSurfaceNormal(x, z) {
            const eps = 2.0;
            const h0 = getMeshHeight(x, z);
            const h1 = getMeshHeight(x + eps, z);
            const h2 = getMeshHeight(x, z + eps);
            vecA.set(x, h0, z);
            vecB.set(x + eps, h1, z);
            vecC.set(x, h2, z + eps);
            sub1.subVectors(vecB, vecA);
            sub2.subVectors(vecC, vecA);
            sub1.cross(sub2).normalize();
            if (sub1.y < 0) sub1.negate();
            return sub1.clone();
        }

        function generateTerrain() {
            const posAttr = geo.attributes.position;
            const colAttr = geo.attributes.color;
            let vIdx = 0;
            const startX = -(WORLD_SIZE/2);
            const startZ = -(WORLD_SIZE/2);

            for (let i = 0; i <= RES; i++) { 
                const worldZ = startZ + (i * SEGMENT_SIZE);
                for (let j = 0; j <= RES; j++) { 
                    const worldX = startX + (j * SEGMENT_SIZE);
                    const h = getRawHeight(worldX, worldZ);
                    posAttr.setY(vIdx, h);
                    const biome = getBiomeData(worldX, worldZ, h);
                    let r = biome.r; let g = biome.g; let b = biome.b;
                    const n = Math.random() * 0.05;
                    colAttr.setXYZ(vIdx, r+n, g+n, b+n);
                    vIdx++;
                }
            }
            geo.computeVertexNormals();
            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            scene.add(terrain);
        }

        // --- PLAYER BODY ---
        const charParts = {};
        function createHuman() {
            const group = new THREE.Group();
            const suitMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.5 });
            const padMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 }); 
            const bodyOffsetZ = -0.25; 

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.65, 0.25), suitMat);
            torso.position.set(0, 1.05, bodyOffsetZ); torso.castShadow = true; group.add(torso);
            const chestPlate = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.25, 0.05), padMat);
            chestPlate.position.set(0, 1.15, bodyOffsetZ - 0.13); group.add(chestPlate);

            const legGeo = new THREE.CapsuleGeometry(0.12, 0.5, 4, 8);
            const leftLeg = new THREE.Mesh(legGeo, suitMat); 
            leftLeg.position.set(-0.15, 0.5, bodyOffsetZ); leftLeg.castShadow = true; group.add(leftLeg); charParts.leftLeg = leftLeg;
            const rightLeg = new THREE.Mesh(legGeo, suitMat); 
            rightLeg.position.set(0.15, 0.5, bodyOffsetZ); rightLeg.castShadow = true; group.add(rightLeg); charParts.rightLeg = rightLeg;

            const bootGeo = new THREE.BoxGeometry(0.18, 0.15, 0.3);
            const lBoot = new THREE.Mesh(bootGeo, padMat); lBoot.position.set(0, -0.35, -0.05); leftLeg.add(lBoot);
            const rBoot = new THREE.Mesh(bootGeo, padMat); rBoot.position.set(0, -0.35, -0.05); rightLeg.add(rBoot);
            
            const armGeo = new THREE.CapsuleGeometry(0.09, 0.5, 4, 8);
            const leftArm = new THREE.Mesh(armGeo, suitMat);
            leftArm.position.set(-0.35, 1.3, bodyOffsetZ); leftArm.rotation.z = 0.1; leftArm.castShadow = true; group.add(leftArm); charParts.leftArm = leftArm;
            const rightArm = new THREE.Mesh(armGeo, suitMat);
            rightArm.position.set(0.35, 1.3, bodyOffsetZ); rightArm.rotation.z = -0.1; rightArm.castShadow = true; group.add(rightArm); charParts.rightArm = rightArm;

            const gloveGeo = new THREE.BoxGeometry(0.12, 0.15, 0.12);
            const lGlove = new THREE.Mesh(gloveGeo, padMat); lGlove.position.set(0, -0.35, 0); leftArm.add(lGlove);
            const rGlove = new THREE.Mesh(gloveGeo, padMat); rGlove.position.set(0, -0.35, 0); rightArm.add(rGlove);

            scene.add(group);
            return group;
        }
        const playerMesh = createHuman();

        // --- COLLECTIBLES (STICKS & GRASS) ---
        const sticks = [];
        const stickGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.8, 5);
        const stickMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
        const grassBundleGeo = new THREE.ConeGeometry(0.2, 0.6, 6);
        const grassBundleMat = new THREE.MeshStandardMaterial({ color: 0x55ff55 });

        window.craftHikingSticks = function() {
            if (player.sticks >= 2) {
                player.sticks -= 2;
                player.hasHikingSticks = true;
                document.getElementById('stick-count').innerText = player.sticks + "/2";
                document.getElementById('gear-disp').innerText = "HIKING STICKS";
                document.getElementById('gear-disp').className = "gear-active";
                document.getElementById('crafting-menu').style.display = 'none';
                document.getElementById('craft-prompt').style.display = 'none';
                try { document.body.requestPointerLock(); } catch(e){}
            }
        };

        window.closeCrafting = function() {
            document.getElementById('crafting-menu').style.display = 'none';
            try { document.body.requestPointerLock(); } catch(e){}
        };

        function spawnCollectibles() {
            // Sticks
            for(let i=0; i<300; i++) {
                spawnSingleItem('stick');
            }
            // Grass
            for(let i=0; i<200; i++) {
                spawnSingleItem('grass');
            }
        }

        function spawnSingleItem(type) {
            let spawned = false;
            let attempts = 0;
            while(!spawned && attempts < 10) {
                attempts++;
                const angle = Math.random() * Math.PI * 2;
                const r = 200 + Math.random() * 10000; 
                const tx = Math.cos(angle)*r; const tz = Math.sin(angle)*r;
                const h = getMeshHeight(tx, tz);
                const biome = getBiomeData(tx, tz, h);
                if (biome.type === 'FOREST' || biome.type === 'GRASSLAND') {
                    const geo = (type === 'stick') ? stickGeo : grassBundleGeo;
                    const mat = (type === 'stick') ? stickMat : grassBundleMat;
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(tx, h + 0.1, tz);
                    if(type === 'stick') {
                        mesh.rotation.z = Math.PI / 2;
                        mesh.rotation.y = Math.random() * Math.PI;
                    }
                    mesh.castShadow = true;
                    scene.add(mesh);
                    sticks.push({ mesh: mesh, active: true, type: type });
                    spawned = true;
                }
            }
        }

        // --- ANIMALS ---
        const animals = [];
        
        function createTitanBunny(scale) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xaaddff, roughness: 0.8 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x557799, roughness: 0.9 });
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
            const toothMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const body = new THREE.Mesh(new THREE.DodecahedronGeometry(1.0, 1), mat);
            body.scale.set(1.1, 0.9, 1.3); body.position.y = 1.2; body.castShadow = true; group.add(body);
            
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 1.9, 0.8);
            group.add(headGroup);

            const head = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.9, 1.0), mat);
            headGroup.add(head);

            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.3), darkMat);
            snout.position.set(0, -0.1, 0.6); headGroup.add(snout);

            const toothL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.05), toothMat);
            toothL.position.set(-0.1, -0.35, 0.65); headGroup.add(toothL);
            const toothR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.05), toothMat);
            toothR.position.set(0.1, -0.35, 0.65); headGroup.add(toothR);

            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat);
            eyeL.position.set(-0.3, 0.1, 0.5); headGroup.add(eyeL);
            const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat);
            eyeR.position.set(0.3, 0.1, 0.5); headGroup.add(eyeR);

            const earGeo = new THREE.CapsuleGeometry(0.12, 1.0, 4, 8);
            const earL = new THREE.Mesh(earGeo, mat); earL.position.set(-0.3, 0.7, 0); earL.rotation.z = 0.2; headGroup.add(earL);
            const earR = new THREE.Mesh(earGeo, mat); earR.position.set(0.3, 0.7, 0); earR.rotation.z = -0.2; headGroup.add(earR);
            
            const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.8);
            const legFL = new THREE.Mesh(legGeo, mat); legFL.position.set(-0.5, 0.4, 0.6); group.add(legFL);
            const legFR = new THREE.Mesh(legGeo, mat); legFR.position.set(0.5, 0.4, 0.6); group.add(legFR);
            const legBL = new THREE.Mesh(legGeo, mat); legBL.position.set(-0.6, 0.4, -0.6); group.add(legBL);
            const legBR = new THREE.Mesh(legGeo, mat); legBR.position.set(0.6, 0.4, -0.6); group.add(legBR);
            
            const pawGeo = new THREE.SphereGeometry(0.2);
            const pawFL = new THREE.Mesh(pawGeo, darkMat); pawFL.position.y = -0.4; legFL.add(pawFL);
            const pawFR = new THREE.Mesh(pawGeo, darkMat); pawFR.position.y = -0.4; legFR.add(pawFR);
            const pawBL = new THREE.Mesh(pawGeo, darkMat); pawBL.position.y = -0.4; legBL.add(pawBL);
            const pawBR = new THREE.Mesh(pawGeo, darkMat); pawBR.position.y = -0.4; legBR.add(pawBR);

            const tail = new THREE.Mesh(new THREE.SphereGeometry(0.4), mat); tail.position.set(0, 1.2, -1.2); group.add(tail);
            
            group.scale.set(scale, scale, scale);
            return { mesh: group, mat: mat, parts: { body, headGroup, earL, earR, legFL, legFR, legBL, legBR } };
        }

        // --- REALISTIC COW MODEL (With 2 Ears) ---
        function createSpaceCow() {
            const group = new THREE.Group();
            const coatColor = 0xA0522D; 
            const noseColor = 0xE6C2B0;
            const hoofColor = 0x1a1a1a;
            const eyeColor = 0x000000;
            
            const mat = new THREE.MeshStandardMaterial({ color: coatColor, roughness: 0.9, flatShading: true });
            const noseMat = new THREE.MeshStandardMaterial({ color: noseColor, roughness: 0.5 });
            const hoofMat = new THREE.MeshStandardMaterial({ color: hoofColor, roughness: 0.9 });
            const eyeMat = new THREE.MeshStandardMaterial({ color: eyeColor, roughness: 0.1 });
            const hornMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.5 });

            const bodyGeo = new THREE.BoxGeometry(1.4, 1.4, 2.2);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 1.6; body.castShadow = true;
            group.add(body);

            const neckGroup = new THREE.Group();
            neckGroup.position.set(0, 2.0, 1.0); 
            group.add(neckGroup);

            const neckGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const neck = new THREE.Mesh(neckGeo, mat);
            neck.position.set(0, -0.2, 0.2); neck.rotation.x = -0.2;
            neckGroup.add(neck);

            const headGroup = new THREE.Group();
            headGroup.position.set(0, 0, 0.6);
            neckGroup.add(headGroup);

            const skullGeo = new THREE.BoxGeometry(0.9, 0.8, 0.7);
            const skull = new THREE.Mesh(skullGeo, mat);
            headGroup.add(skull);

            const snoutGeo = new THREE.BoxGeometry(0.92, 0.35, 0.35);
            const snout = new THREE.Mesh(snoutGeo, noseMat);
            snout.position.set(0, -0.22, 0.35);
            headGroup.add(snout);

            const nostrilGeo = new THREE.BoxGeometry(0.1, 0.05, 0.02);
            const nostrilL = new THREE.Mesh(nostrilGeo, eyeMat); nostrilL.position.set(-0.25, -0.2, 0.53); headGroup.add(nostrilL);
            const nostrilR = new THREE.Mesh(nostrilGeo, eyeMat); nostrilR.position.set(0.25, -0.2, 0.53); headGroup.add(nostrilR);

            const eyeGeo = new THREE.SphereGeometry(0.12);
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.46, 0.1, 0.1); headGroup.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(0.46, 0.1, 0.1); headGroup.add(eyeR);

            // Distinct Ears (Pointy & Visible)
            const earGeo = new THREE.ConeGeometry(0.15, 0.5, 4);
            const earL = new THREE.Mesh(earGeo, mat); 
            earL.position.set(-0.6, 0.3, 0); 
            earL.rotation.set(0, 0, 1.2); 
            headGroup.add(earL);
            const earR = new THREE.Mesh(earGeo, mat); 
            earR.position.set(0.6, 0.3, 0); 
            earR.rotation.set(0, 0, -1.2); 
            headGroup.add(earR);

            const hairGeo = new THREE.DodecahedronGeometry(0.2);
            const hair = new THREE.Mesh(hairGeo, mat);
            hair.position.set(0, 0.45, 0.1); hair.scale.set(1, 0.5, 1);
            headGroup.add(hair);

            const hornGeo = new THREE.ConeGeometry(0.04, 0.15, 8);
            const hornL = new THREE.Mesh(hornGeo, hornMat); hornL.position.set(-0.3, 0.45, -0.1); hornL.rotation.z = -0.2; headGroup.add(hornL);
            const hornR = new THREE.Mesh(hornGeo, hornMat); hornR.position.set(0.3, 0.45, -0.1); hornR.rotation.z = 0.2; headGroup.add(hornR);

            function createLeg(x, z) {
                const legGroup = new THREE.Group();
                legGroup.position.set(x, 1.0, z);
                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.7, 0.4), mat); upper.position.y = -0.35; legGroup.add(upper);
                const lower = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.6, 0.3), mat); lower.position.y = -1.0; legGroup.add(lower);
                const hoof = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.15, 0.32), hoofMat); hoof.position.y = -1.35; legGroup.add(hoof);
                return legGroup;
            }

            const legFL = createLeg(-0.6, 0.9); group.add(legFL);
            const legFR = createLeg(0.6, 0.9); group.add(legFR);
            const legBL = createLeg(-0.6, -0.9); group.add(legBL);
            const legBR = createLeg(0.6, -0.9); group.add(legBR);

            const tailGeo = new THREE.CylinderGeometry(0.08, 0.05, 1.2);
            const tail = new THREE.Mesh(tailGeo, mat);
            tail.position.set(0, 1.5, -1.1); tail.rotation.x = 0.5;
            const tuft = new THREE.Mesh(new THREE.SphereGeometry(0.15), mat); tuft.position.y = -0.6; tail.add(tuft);
            group.add(tail);

            const udder = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.3, 0.7), new THREE.MeshStandardMaterial({color: 0xffaaaa}));
            udder.position.set(0, 0.8, -0.2);
            group.add(udder);

            group.scale.set(4.0, 4.0, 4.0);

            return { 
                mesh: group, 
                parts: { neckGroup, headGroup, legFL, legFR, legBL, legBR, tail } 
            };
        }

        function spawnAnimals() {
            for(let i=0; i<30; i++) {
                const cowObj = createSpaceCow();
                const mesh = cowObj.mesh;
                let spawned = false;
                let attempts = 0;
                while(!spawned && attempts < 100) {
                    attempts++;
                    const angle = Math.random() * Math.PI * 2;
                    const r = 500 + Math.random() * 8000;
                    const tx = Math.cos(angle)*r; const tz = Math.sin(angle)*r;
                    const norm = getSurfaceNormal(tx, tz);
                    if(norm.y > 0.8) { 
                        mesh.position.set(tx, 0, tz); 
                        spawned = true; 
                    }
                }
                if(spawned) {
                    scene.add(mesh);
                    animals.push({ 
                        mesh: mesh, type: 'cow', parts: cowObj.parts,
                        dir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(), 
                        timer: 0, state: 'IDLE', animOffset: Math.random() * 100,
                        nextStateTime: 100 + Math.random() * 200,
                        radius: 3.5,
                        tamed: false
                    });
                }
            }

            for(let i=0; i<40; i++) {
                const titanObj = createTitanBunny(3.5);
                const mesh = titanObj.mesh;
                let spawned = false;
                let attempts = 0;
                while(!spawned && attempts < 200) {
                    attempts++;
                    const angle = Math.random() * Math.PI * 2;
                    const r = 500 + Math.random() * 9500;
                    const tx = Math.cos(angle)*r; const tz = Math.sin(angle)*r;
                    const h = getMeshHeight(tx, tz);
                    const biome = getBiomeData(tx, tz, h);
                    if(biome.type === 'FOREST' && isPositionFree(tx, tz, 5.0)) { 
                        mesh.position.set(tx, 0, tz); 
                        spawned = true; 
                    }
                }
                if(spawned) {
                    scene.add(mesh);
                    animals.push({ 
                        mesh: mesh, type: 'titan', mat: titanObj.mat, parts: titanObj.parts,
                        dir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(), 
                        timer: 0, state: 'WANDER', animOffset: Math.random() * 100,
                        radius: 2.0
                    });
                }
            }
        }

        // --- VEGETATION ---
        const treeCount = 28000; const bushCount = 45000; 
        const foliageGeo = new THREE.ConeGeometry(9, 16, 6); foliageGeo.translate(0, 16, 0);
        const trunkGeo = new THREE.CylinderGeometry(1.0, 1.4, 16, 5); trunkGeo.translate(0, 8, 0);
        const foliageMat = new THREE.MeshStandardMaterial({ color: 0x225522, roughness: 0.9, flatShading: true }); 
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5a4d3b, roughness: 1.0, flatShading: true });
        const foliageMesh = new THREE.InstancedMesh(foliageGeo, foliageMat, treeCount);
        const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
        
        const mushStemGeo = new THREE.CylinderGeometry(1, 1.5, 10, 6); mushStemGeo.translate(0, 5, 0);
        const mushCapGeo = new THREE.ConeGeometry(5, 4, 8); mushCapGeo.translate(0, 12, 0);
        const mushMat = new THREE.MeshStandardMaterial({ color: 0xaa3333, roughness: 0.8 });
        const mushStemMat = new THREE.MeshStandardMaterial({ color: 0xddccaa });
        const mushStemMesh = new THREE.InstancedMesh(mushStemGeo, mushStemMat, 8000);
        const mushCapMesh = new THREE.InstancedMesh(mushCapGeo, mushMat, 8000);

        const grassGeo = new THREE.BufferGeometry();
        const v1 = [ -0.75, 0, 0, 0.75, 0, 0, -0.75, 3, 0, 0.75, 0, 0, 0.75, 3, 0, -0.75, 3, 0 ];
        const v2 = [ 0, 0, -0.75, 0, 0, 0.75, 0, 3, -0.75, 0, 0, 0.75, 0, 3, 0.75, 0, 3, -0.75 ];
        const verts = new Float32Array([...v1, ...v2]);
        grassGeo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        const uvs1 = [ 0,0, 1,0, 0,1,  1,0, 1,1, 0,1 ];
        const uvs = new Float32Array([...uvs1, ...uvs1]);
        grassGeo.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

        const grassMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0x44aa44) } },
            vertexShader: `
                varying vec2 vUv; varying float vHeight; uniform float time;
                void main() {
                    vUv = uv; vHeight = position.y; vec3 pos = position;
                    vec4 worldPosition = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                    if(pos.y > 0.5) {
                        float wave = sin(time * 1.5 + worldPosition.x * 0.05 + worldPosition.z * 0.05) * 0.5;
                        wave += sin(time * 3.0 + worldPosition.x * 0.1) * 0.1;
                        pos.x += wave * (pos.y * 0.3); pos.z += wave * 0.5 * (pos.y * 0.3);
                    }
                    gl_Position = projectionMatrix * viewMatrix * (instanceMatrix * vec4(pos, 1.0));
                }
            `,
            fragmentShader: `varying vec2 vUv; varying float vHeight; uniform vec3 color; void main() { vec3 gradientColor = mix(color * 0.2, color * 1.3, vHeight / 3.0); if(gradientColor.g < 0.1) discard; gl_FragColor = vec4(gradientColor, 1.0); }`,
            side: THREE.DoubleSide
        });

        const grassCount = 350000; 
        const grassMesh = new THREE.InstancedMesh(grassGeo, grassMaterial, grassCount);

        const rockGeo = new THREE.DodecahedronGeometry(3, 0); 
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
        const rockMesh = new THREE.InstancedMesh(rockGeo, rockMat, 10000);

        const bushGeo = new THREE.DodecahedronGeometry(1.5, 0); bushGeo.translate(0, 1.0, 0);
        const bushMat = new THREE.MeshStandardMaterial({ color: 0x226622, roughness: 1.0, flatShading: true });
        const bushMesh = new THREE.InstancedMesh(bushGeo, bushMat, bushCount);
        
        const dummy = new THREE.Object3D();
        const collisionGrid = {}; 

        function addToGrid(x, z, r) {
            const key = `${Math.floor(x/200)},${Math.floor(z/200)}`;
            if(!collisionGrid[key]) collisionGrid[key] = []; collisionGrid[key].push({x, z, r});
        }

        function isPositionFree(px, pz, radiusCheck) {
            const cx = Math.floor(px/200); const cz = Math.floor(pz/200);
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    const cell = collisionGrid[`${cx+i},${cz+j}`];
                    if(cell) for(let k=0; k<cell.length; k++) {
                        const dx = px - cell[k].x; const dz = pz - cell[k].z;
                        if((dx*dx + dz*dz) < (radiusCheck + cell[k].r)**2) return false;
                    }
                }
            }
            return true;
        }

        function plantVegetation() {
            let tIdx = 0; let mIdx = 0; let gIdx = 0; let rIdx = 0;
            let attempts = 0;
            const loopMax = 150000; 

            while((tIdx < treeCount || mIdx < 8000) && attempts < loopMax) {
                attempts++;
                const angle = Math.random() * Math.PI * 2; 
                const r = 100 + Math.random() * 14500; 
                const tx = Math.cos(angle) * r; const tz = Math.sin(angle) * r;
                const y = getMeshHeight(tx, tz);
                const normal = getSurfaceNormal(tx, tz);
                const isFlat = normal.y > 0.75;
                const biome = getBiomeData(tx, tz, y);
                
                if(y > -10 && isPositionFree(tx, tz, 10) && isFlat) {
                    if (tIdx < treeCount && (biome.type === 'FOREST' || (biome.type === 'GRASSLAND' && Math.random() > 0.7))) {
                        dummy.position.set(tx, y, tz);
                        const s = 0.8 + Math.random() * 1.5; dummy.scale.set(s,s,s);
                        dummy.rotation.set(0, Math.random()*3, 0);
                        dummy.updateMatrix();
                        foliageMesh.setMatrixAt(tIdx, dummy.matrix); trunkMesh.setMatrixAt(tIdx, dummy.matrix);
                        addToGrid(tx, tz, 2.0); tIdx++;
                    } else if (mIdx < 8000 && biome.type === 'FOREST' && Math.random() > 0.5) {
                        dummy.position.set(tx, y, tz);
                        const s = 0.5 + Math.random() * 1.5; dummy.scale.set(s,s,s);
                        dummy.rotation.set(0, Math.random()*3, 0);
                        dummy.updateMatrix();
                        mushStemMesh.setMatrixAt(mIdx, dummy.matrix); mushCapMesh.setMatrixAt(mIdx, dummy.matrix);
                        addToGrid(tx, tz, 1.5); mIdx++;
                    }
                }
            }
            foliageMesh.count = tIdx; trunkMesh.count = tIdx;
            mushStemMesh.count = mIdx; mushCapMesh.count = mIdx;
            scene.add(foliageMesh); scene.add(trunkMesh);
            scene.add(mushStemMesh); scene.add(mushCapMesh);

            let bIdx = 0;
            for(let i=0; i<400000; i++) { 
                const angle = Math.random() * Math.PI * 2; 
                const r = 120 + Math.random() * 14500; 
                const bx = Math.cos(angle) * r; const bz = Math.sin(angle) * r;
                const y = getMeshHeight(bx, bz);
                const biome = getBiomeData(bx, bz, y);

                if(y > -10) {
                    if(bIdx < bushCount && biome.type !== 'SNOW') {
                         const normal = getSurfaceNormal(bx, bz);
                         if (normal.y > 0.6) { 
                            dummy.position.set(bx, y, bz);
                            const s = 1.0 + Math.random() * 2.0; dummy.scale.set(s,s,s);
                            dummy.updateMatrix();
                            bushMesh.setMatrixAt(bIdx, dummy.matrix); bIdx++;
                         }
                    }
                    if(gIdx < grassCount && (biome.type === 'GRASSLAND' || biome.type === 'FOREST' || (biome.type === 'HIGHLANDS' && Math.random() > 0.4))) {
                        dummy.position.set(bx, y, bz);
                        const s = 1.2 + Math.random() * 0.8; dummy.scale.set(s,s,s);
                        dummy.rotation.set(0, Math.random()*Math.PI, 0); dummy.updateMatrix();
                        grassMesh.setMatrixAt(gIdx, dummy.matrix); gIdx++;
                    }
                    if(rIdx < 10000 && (biome.type === 'ROCKY_SLOPES' || biome.type === 'MOUNTAIN')) {
                        dummy.position.set(bx, y, bz);
                        const s = 1.0 + Math.random() * 4.0; dummy.scale.set(s,s,s);
                        dummy.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
                        dummy.updateMatrix();
                        rockMesh.setMatrixAt(rIdx, dummy.matrix); rIdx++;
                    }
                }
            }
            bushMesh.count = bIdx; rockMesh.count = rIdx; grassMesh.count = gIdx;
            scene.add(bushMesh); scene.add(rockMesh); scene.add(grassMesh);
        }
        
        function checkTreeCollision(px, pz) {
            const cx = Math.floor(px/200); const cz = Math.floor(pz/200);
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    const cell = collisionGrid[`${cx+i},${cz+j}`];
                    if(cell) for(let k=0; k<cell.length; k++) {
                        if((px - cell[k].x)**2 + (pz - cell[k].z)**2 < (3.5)**2) return true;
                    }
                }
            }
            return false;
        }

        // Check collision against specific entities (cows)
        function checkEntityCollision(px, pz, ignoreMount) {
            for(let i=0; i<animals.length; i++) {
                const anim = animals[i];
                if(anim === ignoreMount) continue;
                if(anim.type === 'cow') {
                    const dx = px - anim.mesh.position.x;
                    const dz = pz - anim.mesh.position.z;
                    if(dx*dx + dz*dz < 4.0 * 4.0) return true;
                }
            }
            return false;
        }

        // --- STATE ---
        const player = { 
            x: 0, z: 0, speed: 0, angle: 0, pitch: 0, y: 0, velocityY: 0, 
            isGrounded: true, stamina: 100, health: 100, isClimbing: false, 
            sticks: 0, grass: 0, hasHikingSticks: false,
            knX: 0, knZ: 0,
            isRiding: false, mount: null
        };
        const keys = { w:0, s:0, a:0, d:0, shift:0, space: 0, e: 0 };
        let lastSpacePress = false; let animationTime = 0; 
        let hasPointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
        let isLocked = false; let isMouseDown = false;
        let btnUp = false; let btnDown = false;
        let timeOfDay = 0.5;
        let smoothCamY = 0; 
        let pickupTimer = 0;

        window.addEventListener('keydown', e => {
            if(e.code === 'KeyW') keys.w = 1; if(e.code === 'KeyS') keys.s = 1;
            if(e.code === 'KeyA') keys.a = 1; if(e.code === 'KeyD') keys.d = 1;
            if(e.code === 'ShiftLeft') keys.shift = 1; if(e.code === 'Space') keys.space = 1;
            if(e.code === 'ArrowUp') keys.up = 1; if(e.code === 'ArrowDown') keys.down = 1;
            if(e.code === 'KeyC') {
                if(player.sticks >= 2 && !player.hasHikingSticks) {
                    document.getElementById('crafting-menu').style.display = 'block';
                    document.exitPointerLock();
                }
            }
            if(e.code === 'KeyE') {
                if(player.isRiding) {
                    // Dismount handled in animate
                } else {
                    // Check near cow
                    let nearest = null; let minDst = 10.0;
                    for(let i=0; i<animals.length; i++) {
                        if(animals[i].type === 'cow') {
                            const d = animals[i].mesh.position.distanceTo(new THREE.Vector3(player.x, player.y, player.z));
                            if(d < 6.0 && d < minDst) { minDst = d; nearest = animals[i]; }
                        }
                    }
                    if(nearest) {
                        if(nearest.tamed) {
                            player.isRiding = true;
                            player.mount = nearest;
                        } else if(player.grass >= 3) {
                            player.grass -= 3;
                            document.getElementById('grass-count').innerText = player.grass;
                            nearest.tamed = true;
                            nearest.mesh.scale.multiplyScalar(1.1); // Grow slightly
                        }
                    }
                }
            }
        });
        window.addEventListener('keyup', e => {
            if(e.code === 'KeyW') keys.w = 0; if(e.code === 'KeyS') keys.s = 0;
            if(e.code === 'KeyA') keys.a = 0; if(e.code === 'KeyD') keys.d = 0;
            if(e.code === 'ShiftLeft') keys.shift = 0; if(e.code === 'Space') keys.space = 0; 
            if(e.code === 'ArrowUp') keys.up = 0; if(e.code === 'ArrowDown') keys.down = 0;
            lastSpacePress = false;
        });

        const bUp = document.getElementById('btn-up'); const bDown = document.getElementById('btn-down');
        bUp.addEventListener('mousedown', () => btnUp = true); bUp.addEventListener('mouseup', () => btnUp = false);
        bUp.addEventListener('touchstart', (e) => { e.preventDefault(); btnUp = true; }); bUp.addEventListener('touchend', (e) => { e.preventDefault(); btnUp = false; });
        bDown.addEventListener('mousedown', () => btnDown = true); bDown.addEventListener('mouseup', () => btnDown = false);
        bDown.addEventListener('touchstart', (e) => { e.preventDefault(); btnDown = true; }); bDown.addEventListener('touchend', (e) => { e.preventDefault(); btnDown = false; });

        document.addEventListener('mousedown', (e) => { if(e.target.classList.contains('look-btn') || e.target.classList.contains('craft-btn') || e.target.classList.contains('btn')) return; isMouseDown = true; });
        document.addEventListener('mouseup', () => { isMouseDown = false; });
        document.addEventListener('pointerlockchange', () => { isLocked = (document.pointerLockElement === document.body); });
        document.addEventListener('click', (e) => { 
            if(e.target.classList.contains('look-btn') || e.target.closest('#crafting-menu') || e.target.closest('.btn')) return;
            if(gameActive && hasPointerLock && !isLocked) try { document.body.requestPointerLock(); } catch(e){} 
        });

        document.addEventListener('mousemove', (e) => {
            if (!gameActive) return;
            if (isLocked || isMouseDown) {
                player.angle -= e.movementX * 0.002;
                player.pitch -= e.movementY * 0.003; 
                const maxDown = -Math.PI / 2 + 0.1; const maxUp = Math.PI / 2.2; 
                if(player.pitch > maxUp) player.pitch = maxUp; if(player.pitch < maxDown) player.pitch = maxDown;
            }
        });

        window.startGame = function() {
            if(hasPointerLock) { try { document.body.requestPointerLock(); } catch(e) {} }
            document.getElementById('loading').style.display = 'block';
            setTimeout(() => {
                generateTerrain();
                plantVegetation();
                spawnAnimals();
                spawnCollectibles();
                document.getElementById('start-screen').style.display = 'none';
                player.x = 0; player.z = 0; player.y = getMeshHeight(0,0);
                smoothCamY = player.y + 1.7; // Init
                gameActive = true; animate();
            }, 100);
        };

        function updateDayNight() {
            timeOfDay += 0.000007; if(timeOfDay > 1) timeOfDay = 0;
            const phi = (timeOfDay + 0.25) * Math.PI * 2; 
            const r = 10000;
            sunLight.position.set(r * Math.cos(phi), r * Math.sin(phi), 0);
            sunSphere.position.copy(sunLight.position);
            const isDay = timeOfDay > 0.25 && timeOfDay < 0.75;
            const isSunset = (timeOfDay > 0.2 && timeOfDay < 0.25) || (timeOfDay > 0.75 && timeOfDay < 0.8);
            let skyHex = 0x000000; let fogHex = 0x000000; let sunInt = 0; let hemiInt = 0;
            if(isDay) { skyHex = 0x88ccff; fogHex = 0xbbeeff; sunInt = 2.2; hemiInt = 0.8; }
            else if (isSunset) { skyHex = 0xff9944; fogHex = 0xffaa66; sunInt = 0.8; hemiInt = 0.3; }
            else { skyHex = 0x000510; fogHex = 0x000510; sunInt = 0.0; hemiInt = 0.05; }
            scene.background.lerp(new THREE.Color(skyHex), 0.01);
            fog.color.lerp(new THREE.Color(fogHex), 0.01);
            sunLight.intensity = THREE.MathUtils.lerp(sunLight.intensity, sunInt, 0.01);
            hemiLight.intensity = THREE.MathUtils.lerp(hemiLight.intensity, hemiInt, 0.01);
            starMat.opacity = THREE.MathUtils.lerp(starMat.opacity, (sunInt > 0.2) ? 0 : 0.8, 0.01);
            const hrs = Math.floor(timeOfDay * 24); const mins = Math.floor((timeOfDay * 24 * 60) % 60);
            document.getElementById('time-disp').innerText = `${hrs.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}`;
        }

        function updateAnimals() {
            const time = Date.now() * 0.001;
            const dmgOverlay = document.getElementById('damage-overlay');
            dmgOverlay.style.display = 'none';

            // Interaction Prompt Logic
            let promptText = "";
            if(!player.isRiding) {
                let nearest = null; let minDst = 10.0;
                for(let i=0; i<animals.length; i++) {
                    if(animals[i].type === 'cow') {
                        const d = animals[i].mesh.position.distanceTo(new THREE.Vector3(player.x, player.y, player.z));
                        if(d < 6.0 && d < minDst) { minDst = d; nearest = animals[i]; }
                    }
                }
                if(nearest) {
                    if(nearest.tamed) promptText = "[E] RIDE";
                    else if(player.grass >= 3) promptText = "[E] FEED (3 GRASS)";
                    else promptText = "NEED 3 GRASS TO TAME";
                }
            }
            const promptEl = document.getElementById('interaction-prompt');
            if(promptText !== "") { promptEl.style.display = 'block'; promptEl.innerText = promptText; }
            else promptEl.style.display = 'none';

            for(let i=0; i<animals.length; i++) {
                const anim = animals[i];
                anim.timer++;
                
                // --- COW LOGIC ---
                if(anim.type === 'cow') {
                    
                    if (player.isRiding && player.mount === anim) {
                        // PLAYER CONTROLLED
                        const h = getMeshHeight(anim.mesh.position.x, anim.mesh.position.z);
                        anim.mesh.position.y = h;
                        
                        if (keys.w || keys.s || keys.a || keys.d) {
                            const t = time * 15; 
                            anim.parts.legFL.rotation.x = Math.sin(t) * 0.8;
                            anim.parts.legFR.rotation.x = Math.cos(t) * 0.8;
                            anim.parts.legBL.rotation.x = Math.cos(t) * 0.8;
                            anim.parts.legBR.rotation.x = Math.sin(t) * 0.8;
                        } else {
                            anim.parts.legFL.rotation.x = 0; anim.parts.legFR.rotation.x = 0;
                            anim.parts.legBL.rotation.x = 0; anim.parts.legBR.rotation.x = 0;
                        }
                    } else {
                        // AI CONTROLLED
                        if (anim.timer > anim.nextStateTime) {
                            anim.timer = 0;
                            anim.nextStateTime = 100 + Math.random() * 200;
                            const rand = Math.random();
                            if(rand < 0.4) anim.state = 'WALK';
                            else if(rand < 0.7) anim.state = 'EAT';
                            else anim.state = 'IDLE';
                            if(anim.state === 'WALK') {
                                anim.dir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                            }
                        }
                        if (anim.state === 'WALK') {
                            const normal = getSurfaceNormal(anim.mesh.position.x, anim.mesh.position.z);
                            if (normal.y < 0.8) { anim.dir.x += normal.x * 0.2; anim.dir.z += normal.z * 0.2; anim.dir.normalize(); }
                            anim.mesh.position.addScaledVector(anim.dir, 0.04);
                            const lookTarget = anim.mesh.position.clone().add(anim.dir);
                            anim.mesh.lookAt(lookTarget);
                            anim.parts.neckGroup.rotation.x = THREE.MathUtils.lerp(anim.parts.neckGroup.rotation.x, 0, 0.1);
                            const t = time * 5 + anim.animOffset;
                            anim.parts.legFL.rotation.x = Math.sin(t) * 0.5;
                            anim.parts.legFR.rotation.x = Math.cos(t) * 0.5;
                            anim.parts.legBL.rotation.x = Math.cos(t) * 0.5;
                            anim.parts.legBR.rotation.x = Math.sin(t) * 0.5;
                        } 
                        else if (anim.state === 'EAT') {
                            anim.parts.neckGroup.rotation.x = THREE.MathUtils.lerp(anim.parts.neckGroup.rotation.x, 0.8, 0.1);
                            anim.parts.neckGroup.rotation.y = Math.sin(time * 8) * 0.1;
                        }
                        else {
                            anim.parts.neckGroup.rotation.x = THREE.MathUtils.lerp(anim.parts.neckGroup.rotation.x, 0, 0.1);
                            anim.parts.neckGroup.rotation.y = Math.sin(time) * 0.05;
                        }
                        const h = getMeshHeight(anim.mesh.position.x, anim.mesh.position.z);
                        anim.mesh.position.y = h;
                    }
                    continue; 
                }

                // --- TITAN LOGIC ---
                const currentPos = anim.mesh.position;
                let targetDir = null;
                
                const distToPlayer = Math.sqrt((player.x - currentPos.x)**2 + (player.z - currentPos.z)**2);
                if (distToPlayer < 80) { anim.state = 'ATTACK'; anim.mat.color.setHex(0xff5555); } 
                else if (distToPlayer > 150) { anim.state = 'WANDER'; anim.mat.color.setHex(0xaaddff); }

                if (anim.state === 'ATTACK') {
                    targetDir = new THREE.Vector3(player.x - currentPos.x, 0, player.z - currentPos.z).normalize();
                    anim.dir.lerp(targetDir, 0.1);
                    
                    anim.parts.body.rotation.x = -Math.PI / 4; 
                    
                    if (distToPlayer < 4.0) {
                        dmgOverlay.style.display = 'block';
                        player.health -= 25; 
                        
                        const knockForce = 1.8;
                        player.knX += targetDir.x * knockForce;
                        player.knZ += targetDir.z * knockForce;
                        player.velocityY = 0.5; 
                        player.isGrounded = false;
                        
                        anim.mesh.position.addScaledVector(targetDir, -5.0);
                    }
                } else {
                    anim.parts.body.rotation.x = 0;
                }

                if(anim.state !== 'ATTACK' && anim.timer > 100 + Math.random()*200) { 
                    const randDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                    const lookAheadDist = 10.0;
                    const futureNormal = getSurfaceNormal(currentPos.x + randDir.x * lookAheadDist, currentPos.z + randDir.z * lookAheadDist);
                    if (futureNormal.y < 0.85) { anim.dir.x = futureNormal.x; anim.dir.z = futureNormal.z; anim.dir.normalize(); } 
                    else { anim.dir = randDir; }
                    anim.timer = 0;
                }

                const normal = getSurfaceNormal(currentPos.x, currentPos.z);
                if (normal.y < 0.85) { anim.dir.x += normal.x * 0.1; anim.dir.z += normal.z * 0.1; anim.dir.normalize(); }

                const speed = (anim.state === 'ATTACK') ? 0.22 : 0.06;
                anim.mesh.position.addScaledVector(anim.dir, speed); 

                const h = getMeshHeight(anim.mesh.position.x, anim.mesh.position.z);
                
                const newNormal = getSurfaceNormal(anim.mesh.position.x, anim.mesh.position.z);
                const targetUp = newNormal.clone();
                anim.mesh.up.lerp(targetUp, 0.2); 
                const lookTarget = anim.mesh.position.clone().add(anim.dir);
                anim.mesh.lookAt(lookTarget);

                const freq = (anim.state === 'ATTACK') ? 15.0 : 3.0; 
                const t = time * freq + anim.animOffset;
                const hopHeight = Math.abs(Math.sin(t)) * (anim.state === 'ATTACK' ? 0.8 : 1.5);
                
                anim.mesh.position.y = h;
                anim.mesh.position.addScaledVector(newNormal, hopHeight);
                
                if(anim.parts) {
                    anim.parts.legFL.rotation.x = Math.sin(t) * 0.8; anim.parts.legFR.rotation.x = Math.cos(t) * 0.8;
                    anim.parts.legBL.rotation.x = Math.cos(t) * 0.8; anim.parts.legBR.rotation.x = Math.sin(t) * 0.8;
                }
            }
        }

        function checkStickPickup() {
            if(pickupTimer > 0) {
                pickupTimer--;
                document.getElementById('pickup-msg').style.opacity = (pickupTimer / 50);
            }
            
            for(let i=0; i<sticks.length; i++) {
                if(sticks[i].active) {
                    const dx = player.x - sticks[i].mesh.position.x;
                    const dz = player.z - sticks[i].mesh.position.z;
                    if(dx*dx + dz*dz < 4.0) { 
                        sticks[i].active = false;
                        sticks[i].mesh.visible = false;
                        
                        pickupTimer = 100;
                        document.getElementById('pickup-msg').style.opacity = 1;

                        if(sticks[i].type === 'stick') {
                            player.sticks++;
                            document.getElementById('pickup-msg').innerText = "Stick Collected";
                            document.getElementById('stick-count').innerText = player.sticks + "/2";
                            if(player.sticks >= 2 && !player.hasHikingSticks) {
                                document.getElementById('craft-prompt').style.display = 'block';
                            }
                        } else {
                            player.grass++;
                            document.getElementById('pickup-msg').innerText = "Grass Collected";
                            document.getElementById('grass-count').innerText = player.grass;
                        }
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate); if(!gameActive) return;
            
            updateDayNight();
            updateAnimals();
            checkStickPickup();
            
            if (player.health <= 0) {
                gameActive = false;
                document.getElementById('game-over-screen').style.display = 'flex';
                document.exitPointerLock();
                return;
            }

            grassMaterial.uniforms.time.value = performance.now() * 0.001;

            if(keys.up || btnUp) player.pitch += 0.03;
            if(keys.down || btnDown) player.pitch -= 0.03;
            const maxDown = -Math.PI / 2 + 0.1; const maxUp = Math.PI / 2.2; 
            if(player.pitch > maxUp) player.pitch = maxUp; if(player.pitch < maxDown) player.pitch = maxDown;

            const normal = getSurfaceNormal(player.x, player.z);
            const slopeAngle = Math.acos(normal.y);
            const slopePercent = Math.tan(slopeAngle) * 100;

            const IMPOSSIBLE_SLOPE = player.hasHikingSticks ? 360 : 150;
            const CLIMB_ENTER = 60;
            const CLIMB_EXIT = 50;

            let isImpossible = slopePercent > IMPOSSIBLE_SLOPE;
            
            if (!player.isClimbing && slopePercent > CLIMB_ENTER && !isImpossible && !player.isRiding) {
                player.isClimbing = true;
            } else if (player.isClimbing && slopePercent < CLIMB_EXIT) {
                player.isClimbing = false;
            } else if (isImpossible) {
                player.isClimbing = false;
            }

            // SPACE COW JUMP / DISMOUNT
            if (player.isRiding && keys.space) {
                player.isRiding = false;
                player.mount = null;
                player.velocityY = 0.5;
                player.isGrounded = false;
                lastSpacePress = true;
            }

            const WALK_SPEED = 0.15; const SPRINT_SPEED = 0.35; const CLIMB_SPEED = 0.1; 
            const COW_SPEED = 0.6; // Very fast
            const GRAVITY = 0.02;
            const isMoving = (keys.w || keys.s || keys.a || keys.d);
            let isSprinting = false;

            if (player.isClimbing) {
                if (isMoving) {
                    player.stamina -= 0.15; 
                } else {
                    player.stamina += 0.15; 
                }
                if (player.stamina <= 0) { player.isClimbing = false; isImpossible = true; }
            } else if (keys.shift && isMoving && player.stamina > 0 && !isImpossible && !player.isRiding) {
                isSprinting = true; player.stamina -= 0.3;
            } else {
                if (isMoving) player.stamina += 0.1; else player.stamina += 0.3;
            }
            if(player.stamina < 0) player.stamina = 0; if(player.stamina > 100) player.stamina = 100;
            
            document.getElementById('stamina-bar').style.width = player.stamina + "%";
            if(player.stamina < 20) document.getElementById('stamina-bar').style.background = "#ff3333";
            else document.getElementById('stamina-bar').style.background = "#00ddee";
            
            document.getElementById('health-bar').style.width = player.health + "%";

            document.getElementById('alt-disp').innerText = Math.round(player.y) + "m";
            document.getElementById('slope-disp').innerText = Math.round(slopePercent) + "%";
            document.getElementById('slope-disp').className = "stat-val " + (isImpossible ? "danger" : (player.isClimbing ? "climb" : ""));
            const biomeInfo = getBiomeData(player.x, player.z, player.y);
            document.getElementById('biome-disp').innerText = biomeInfo.type;

            let dx = 0, dz = 0;
            let maxSpeed = player.isRiding ? COW_SPEED : (player.isClimbing ? CLIMB_SPEED : (isSprinting ? SPRINT_SPEED : WALK_SPEED));
            
            // Input Vector
            if (isLocked || isMouseDown) {
                const fwdX = Math.sin(player.angle); const fwdZ = Math.cos(player.angle);
                const rightX = Math.cos(player.angle); const rightZ = -Math.sin(player.angle);
                if (keys.w) { dx -= fwdX; dz -= fwdZ; } if (keys.s) { dx += fwdX; dz += fwdZ; }
                if (keys.a) { dx -= rightX; dz -= rightZ; } if (keys.d) { dx += rightX; dz += rightZ; } 
            } else {
                if (keys.a) player.angle += 0.04; if (keys.d) player.angle -= 0.04;
                const fwdX = Math.sin(player.angle); const fwdZ = Math.cos(player.angle);
                if (keys.w) { dx -= fwdX; dz -= fwdZ; } if (keys.s) { dx += fwdX; dz += fwdZ; }
            }

            if (dx !== 0 || dz !== 0) {
                const len = Math.sqrt(dx*dx + dz*dz);
                dx = (dx/len) * maxSpeed; dz = (dz/len) * maxSpeed;
                
                if (player.isClimbing) {
                    const slopeRatio = Math.tan(slopeAngle); 
                    const surfaceFactor = Math.sqrt(1 + slopeRatio * slopeRatio);
                    dx /= surfaceFactor;
                    dz /= surfaceFactor;
                }
            }
            
            if (isImpossible && !player.isRiding) {
                dx += normal.x * 0.4; dz += normal.z * 0.4; 
            }

            // --- PHYSICS UPDATE ---
            player.knX *= 0.9;
            player.knZ *= 0.9;
            const finalDx = dx + player.knX;
            const finalDz = dz + player.knZ;

            player.speed = THREE.MathUtils.lerp(player.speed, Math.sqrt(finalDx*finalDx + finalDz*finalDz), 0.1);
            
            if(player.isRiding && player.mount) {
                // MOVE MOUNT
                const mount = player.mount;
                const mNorm = getSurfaceNormal(mount.mesh.position.x, mount.mesh.position.z);
                
                // Allow climb but slower
                let mDx = finalDx; let mDz = finalDz;
                if(mNorm.y < 0.6) { mDx *= 0.5; mDz *= 0.5; }

                const newMX = mount.mesh.position.x + mDx;
                const newMZ = mount.mesh.position.z + mDz;
                
                if (!checkTreeCollision(newMX, newMZ)) {
                    mount.mesh.position.x = newMX;
                    mount.mesh.position.z = newMZ;
                }
                
                // Rotation matches movement
                if (mDx !== 0 || mDz !== 0) {
                    const lookT = mount.mesh.position.clone().add(new THREE.Vector3(mDx, 0, mDz));
                    mount.mesh.lookAt(lookT);
                }

                // Snap player to mount
                player.x = mount.mesh.position.x;
                player.z = mount.mesh.position.z;
                
                // Smooth Y for camera - SIT ON TOP OF COW
                const mountY = getMeshHeight(player.x, player.z);
                
                // Body height 1.6 + Body Height 1.4 = ~3.0 high visual top. 
                // Scaled by 4.0 = ~12.0 units high.
                // 9.5 was a bit low, bumping to 11.5
                const rideHeight = 11.5; 
                
                const targetCamY = mountY + rideHeight;
                smoothCamY = THREE.MathUtils.lerp(smoothCamY, targetCamY, 0.2);
                
                // Don't draw player mesh when riding
                playerMesh.visible = false;

            } else {
                // NORMAL MOVEMENT
                playerMesh.visible = true;
                const groundY = getMeshHeight(player.x, player.z);
                player.isGrounded = (player.y <= groundY + 0.1);
                
                if (!player.isGrounded && !player.isClimbing) {
                    player.velocityY -= GRAVITY;
                } else {
                    if (player.velocityY < -0.6) { 
                        const dmg = Math.abs(player.velocityY) * 40;
                        player.health -= dmg;
                        document.getElementById('damage-overlay').style.display = 'block';
                    }
                    
                    player.velocityY = Math.max(0, player.velocityY);
                    if (keys.space && !lastSpacePress && player.stamina > 10 && !isImpossible && !player.isClimbing) {
                        player.velocityY = 0.4; player.isGrounded = false; player.stamina -= 10; lastSpacePress = true;
                    }
                }
                
                if (player.isClimbing) {
                    player.velocityY = 0;
                }

                player.y += player.velocityY;
                
                const newX = player.x + finalDx; 
                const newZ = player.z + finalDz;

                // Check Tree Collision & Cow Collision
                if (!checkTreeCollision(newX, newZ) && !checkEntityCollision(newX, newZ, null)) { 
                    player.x = newX; player.z = newZ; 
                } else { 
                    // Sliding collision
                    if (!checkTreeCollision(player.x, newZ) && !checkEntityCollision(player.x, newZ, null)) player.z = newZ; 
                    else if (!checkTreeCollision(newX, player.z) && !checkEntityCollision(newX, player.z, null)) player.x = newX; 
                }

                const terrainHeight = getMeshHeight(player.x, player.z);
                
                if (player.isClimbing) {
                    player.y = terrainHeight;
                }
                
                if (player.y < terrainHeight) {
                    player.y = terrainHeight;
                    player.velocityY = 0;
                    player.isGrounded = true;
                }
                
                const targetCamY = player.y + 1.7;
                smoothCamY = THREE.MathUtils.lerp(smoothCamY, targetCamY, 0.2); 
            }

            if (isMoving && player.isGrounded) { animationTime += (isSprinting ? 0.3 : 0.15); }
            
            // Camera & Player Mesh Transforms
            if (player.isClimbing && isMoving) {
                const climbCycle = animationTime * 0.5;
                charParts.leftArm.rotation.x = -2.0 + Math.sin(climbCycle) * 0.6;
                charParts.rightArm.rotation.x = -2.0 + Math.cos(climbCycle) * 0.6;
                const bobOffset = Math.sin(animationTime * 0.8) * 0.05;
                camera.position.set(player.x, smoothCamY + bobOffset, player.z);
            } else if (player.isRiding) {
                const bobOffset = Math.sin(animationTime * 1.5) * 0.1; // Bouncy ride
                camera.position.set(player.x, smoothCamY + bobOffset, player.z);
            } else {
                const bobOffset = Math.sin(animationTime) * 0.08;
                const swayOffset = Math.cos(animationTime * 0.5) * 0.04;
                camera.position.set(player.x + swayOffset, smoothCamY + bobOffset, player.z);
                if (charParts.leftLeg) {
                    const walkCycle = Math.sin(animationTime);
                    charParts.leftLeg.rotation.x = walkCycle * 0.5; charParts.rightLeg.rotation.x = -walkCycle * 0.5;
                    charParts.leftArm.rotation.x = -walkCycle * 0.5; charParts.rightArm.rotation.x = walkCycle * 0.5;
                }
            }
            
            camera.rotation.x = player.pitch;
            camera.rotation.y = player.angle;

            playerMesh.position.set(player.x, smoothCamY - 1.7, player.z);
            playerMesh.rotation.y = player.angle + Math.PI; 

            composer.render();
        }
    </script>
</body>
</html>
