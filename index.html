<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Grand Bosnia: Overgrown</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        #hud {
            position: absolute; top: 20px; left: 20px;
            color: #fff; background: rgba(0, 20, 30, 0.6);
            padding: 20px; border-radius: 8px; border-left: 4px solid #00ddee;
            font-size: 14px; pointer-events: none; backdrop-filter: blur(8px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 240px;
            z-index: 20;
        }
        
        .stat-label { font-size: 10px; opacity: 0.7; letter-spacing: 2px; text-transform: uppercase; }
        .stat-val { font-size: 18px; font-weight: 900; color: #fff; float: right; }
        .biome-tag { color: #00ddee; text-shadow: 0 0 10px rgba(0, 221, 238, 0.5); }
        .danger { color: #ff3333; text-shadow: 0 0 10px #ff0000; }
        .climb { color: #ffaa00; text-shadow: 0 0 10px #ffaa00; }
        
        #stamina-container {
            margin-top: 15px; width: 100%; height: 6px;
            background: #112211; border-radius: 3px; overflow: hidden;
        }
        #stamina-bar {
            width: 100%; height: 100%; background: #00ddee;
            box-shadow: 0 0 10px #00ddee; transition: width 0.1s;
        }

        #controls {
            position: absolute; bottom: 30px; left: 30px;
            color: rgba(255,255,255,0.5); font-weight: 600; 
            text-transform: uppercase; letter-spacing: 1px; font-size: 12px;
            pointer-events: none;
        }

        #mobile-look {
            position: absolute; bottom: 40px; right: 30px;
            display: flex; flex-direction: column; gap: 10px;
            z-index: 50;
        }
        .look-btn {
            width: 60px; height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: white; font-size: 24px; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; backdrop-filter: blur(4px);
            user-select: none;
        }
        .look-btn:active { background: rgba(0, 221, 238, 0.4); border-color: #00ddee; }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: #fff; opacity: 0.5;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #000000 0%, #1a2a3a 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 99; cursor: pointer;
        }
        .btn { 
            background: transparent; color: #00ddee; padding: 15px 50px; 
            margin-top: 30px; font-weight: 800; letter-spacing: 3px;
            font-size: 18px; border: 2px solid #00ddee; border-radius: 30px;
            transition: 0.2s; box-shadow: 0 0 15px rgba(0, 221, 238, 0.2);
        }
        .btn:hover { background: #00ddee; color: #000; box-shadow: 0 0 35px rgba(0, 221, 238, 0.6); }
        
        #loading { font-size: 12px; margin-top: 15px; color: #888; display:none; font-family: monospace; }
        #error-box { position: absolute; top: 10px; right: 10px; width: 300px; background: #500; color: #fff; padding: 10px; display: none; font-family: monospace; z-index: 100; border: 1px solid #f00; }
        #time-disp { position: absolute; top: 20px; right: 20px; color: #fff; font-weight: bold; font-family: monospace; font-size: 16px; opacity: 0.8; }
    </style>
    
    <script>
        var startGame = function() {
            alert("Game assets are still loading... Please wait 5 seconds and click again!");
        };
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="error-box"></div>
    <div id="crosshair"></div>
    <div id="time-disp">12:00</div>

    <div id="start-screen">
        <h1 style="font-size:60px; margin-bottom:0px; letter-spacing: 5px; color: #fff;">PLANET BOSNIA</h1>
        <p style="font-size:16px; opacity:0.6; letter-spacing: 4px; text-transform:uppercase;">Overgrown Update</p>
        <div class="btn" onclick="startGame()">INITIATE LANDING</div>
        <div id="loading">Generating Ecosystem...</div>
    </div>

    <div id="hud">
        <div style="border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px; margin-bottom:10px;">
            <span class="stat-label">BIOME</span><br>
            <span id="biome-disp" class="stat-val biome-tag" style="float:none; font-size: 20px;">UNKNOWN</span>
        </div>
        <div>
            <span class="stat-label">ALTITUDE</span>
            <span id="alt-disp" class="stat-val">0m</span>
        </div>
        <div style="clear:both; padding-top:5px;">
            <span class="stat-label">SLOPE</span>
            <span id="slope-disp" class="stat-val">0%</span>
        </div>
        
        <div style="margin-top:20px">
            <span class="stat-label">OXYGEN / STAMINA</span>
            <div id="stamina-container">
                <div id="stamina-bar"></div>
            </div>
        </div>
    </div>
    
    <div id="mobile-look">
        <div class="look-btn" id="btn-up">▲</div>
        <div class="look-btn" id="btn-down">▼</div>
    </div>

    <div id="controls">
        WASD Move // ARROWS Look // SHIFT Run // F Flashlight
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        window.onerror = function(msg, url, lineNo, columnNo, error) {
            const box = document.getElementById('error-box');
            box.style.display = 'block';
            box.innerHTML = `<strong>ERROR:</strong><br>${msg}<br><small>${url}:${lineNo}</small>`;
            return false;
        };

        // --- CONFIG ---
        const WORLD_SIZE = 30000; 
        const RES = 150; 
        const SEGMENT_SIZE = WORLD_SIZE / RES;
        const SEED_X = Math.random() * 10000;
        const SEED_Z = Math.random() * 10000;
        
        // --- SCENE & ATMOSPHERE ---
        let gameActive = false;
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const fog = new THREE.FogExp2(0xaaccff, 0.00025);
        scene.fog = fog;

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 40000); 
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", depth: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap; 
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3; 
        document.body.appendChild(renderer.domElement);

        // --- PARTICLES ---
        const particlesGeo = new THREE.BufferGeometry();
        const particlesCount = 4000; 
        const pArray = new Float32Array(particlesCount * 3);
        for(let i=0; i<particlesCount*3; i++) {
            pArray[i] = (Math.random() - 0.5) * 200; 
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pArray, 3));
        const particlesMat = new THREE.PointsMaterial({
            size: 0.15, color: 0xffffff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending
        });
        const particles = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particles);

        // --- STARS ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 6000;
        const starArr = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starArr[i] = (Math.random() - 0.5) * 12000;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starArr, 3));
        const starMat = new THREE.PointsMaterial({ size: 30, color: 0xffffff, sizeAttenuation: false, transparent: true, opacity: 0 });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- POST PROCESSING ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.6; bloomPass.strength = 0.4; bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.1); 
        scene.add(hemiLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffee, 1.5); 
        sunLight.castShadow = true;
        sunLight.shadow.camera.far = 25000;
        sunLight.shadow.mapSize.set(1024, 1024);
        const d = 4000;
        sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        scene.add(sunLight);

        const sunSphere = new THREE.Mesh(new THREE.SphereGeometry(400, 16, 16), new THREE.MeshBasicMaterial({color: 0xffaa33}));
        scene.add(sunSphere);

        // Flashlight
        const spotLight = new THREE.SpotLight(0xffffff, 0, 150, Math.PI/4, 0.5, 1);
        spotLight.position.set(0,0,0);
        camera.add(spotLight);
        spotLight.target.position.set(0,0,-1);
        camera.add(spotLight.target);
        scene.add(camera); 

        // --- NOISE ---
        const p = new Uint8Array(512);
        const perm = new Uint8Array(512);
        for(let i=0; i<256; i++) p[i] = i;
        for(let i=0; i<256; i++) {
            let r = i + ~~(Math.random() * (256 - i));
            let t = p[i]; p[i] = p[r]; p[r] = t;
        }
        for(let i=0; i<512; i++) perm[i] = p[i & 255];
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        function noise(x, y) {
            const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
            x -= Math.floor(x); y -= Math.floor(y);
            const u = fade(x), v = fade(y);
            const A = perm[X] + Y, B = perm[X + 1] + Y;
            return lerp(v, lerp(u, grad(perm[A], x, y), grad(perm[B], x - 1, y)),
                                lerp(u, grad(perm[A + 1], x, y - 1), grad(perm[B + 1], x - 1, y - 1)));
        }

        // --- TERRAIN ---
        const geo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, RES, RES);
        geo.rotateX(-Math.PI / 2);
        const count = geo.attributes.position.count;
        geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
        const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9, metalness: 0.1, flatShading: true });
        const terrain = new THREE.Mesh(geo, mat);
        terrain.receiveShadow = true;

        function getBiomeData(x, z, height) {
            const moisture = noise(x * 0.0003, z * 0.0003); 
            if (height < 300) {
                if (moisture > 0.2) return { type: 'FOREST', r: 0.1, g: 0.35, b: 0.1 }; 
                return { type: 'GRASSLAND', r: 0.3, g: 0.6, b: 0.15 }; 
            } else if (height < 2500) {
                if (moisture > 0.4) return { type: 'HIGHLANDS', r: 0.25, g: 0.45, b: 0.25 }; 
                return { type: 'ROCKY_SLOPES', r: 0.5, g: 0.45, b: 0.4 }; 
            } else if (height < 5000) {
                return { type: 'MOUNTAIN', r: 0.4, g: 0.4, b: 0.45 }; 
            } else {
                return { type: 'SNOW', r: 0.95, g: 0.95, b: 1.0 }; 
            }
        }

        function getRawHeight(x, z) {
            const nx = x + SEED_X;
            const nz = z + SEED_Z;
            let biome = noise(nx * 0.00015, nz * 0.00015);
            
            let height = noise(nx * 0.001, nz * 0.001) * 150;
            height += noise(nx * 0.005, nz * 0.005) * 30;
            
            if (biome > -0.1) { 
                let mtnHeight = Math.abs(noise(nx * 0.0004, nz * 0.0004)) * 6000;
                mtnHeight += noise(nx * 0.002, nz * 0.002) * 500;
                const terraceSize = 150; 
                let shelf = Math.sin(mtnHeight / terraceSize);
                if (shelf > 0.5) mtnHeight -= (shelf - 0.5) * 30; 
                let blend = (biome + 0.1) * 3; if (blend > 1) blend = 1;
                height = lerp(blend, height, mtnHeight);
            }
            
            if (biome > 0.4) {
                let titanBase = (biome - 0.4) * 2.0; if (titanBase > 1) titanBase = 1;
                let titanHeight = Math.pow(Math.abs(noise(nx * 0.0002, nz * 0.0002)), 2.0) * 25000; 
                titanHeight += Math.abs(noise(nx * 0.001, nz * 0.001)) * 2000;
                height = lerp(titanBase, height, titanHeight);
            }
            
            const dist = Math.sqrt(x*x + z*z);
            let sm = 1.0;
            if (dist < 400) sm = 0.0; 
            else if (dist < 1000) sm = (dist - 400) / 600;
            
            height *= sm; 
            if(height < -20) height = -20;
            return height;
        }

        function getMeshHeight(x, z) {
            const gridX = Math.floor((x + WORLD_SIZE/2) / SEGMENT_SIZE);
            const gridZ = Math.floor((z + WORLD_SIZE/2) / SEGMENT_SIZE);
            const x0 = (gridX * SEGMENT_SIZE) - WORLD_SIZE/2;
            const z0 = (gridZ * SEGMENT_SIZE) - WORLD_SIZE/2;
            const x1 = x0 + SEGMENT_SIZE;
            const z1 = z0 + SEGMENT_SIZE;
            const u = (x - x0) / SEGMENT_SIZE;
            const v = (z - z0) / SEGMENT_SIZE;
            const h00 = getRawHeight(x0, z0);
            const h10 = getRawHeight(x1, z0);
            const h01 = getRawHeight(x0, z1);
            const h11 = getRawHeight(x1, z1);
            if (u + v < 1) return h00 + (h10 - h00) * u + (h01 - h00) * v;
            else return h11 + (h01 - h11) * (1 - u) + (h10 - h11) * (1 - v);
        }

        const vecA = new THREE.Vector3(), vecB = new THREE.Vector3(), vecC = new THREE.Vector3();
        const sub1 = new THREE.Vector3(), sub2 = new THREE.Vector3();
        function getSurfaceNormal(x, z) {
            const eps = 2.0;
            const h0 = getMeshHeight(x, z);
            const h1 = getMeshHeight(x + eps, z);
            const h2 = getMeshHeight(x, z + eps);
            vecA.set(x, h0, z);
            vecB.set(x + eps, h1, z);
            vecC.set(x, h2, z + eps);
            sub1.subVectors(vecB, vecA);
            sub2.subVectors(vecC, vecA);
            sub1.cross(sub2).normalize();
            if (sub1.y < 0) sub1.negate();
            return sub1.clone();
        }

        function generateTerrain() {
            const posAttr = geo.attributes.position;
            const colAttr = geo.attributes.color;
            let vIdx = 0;
            const startX = -(WORLD_SIZE/2);
            const startZ = -(WORLD_SIZE/2);

            for (let i = 0; i <= RES; i++) { 
                const worldZ = startZ + (i * SEGMENT_SIZE);
                for (let j = 0; j <= RES; j++) { 
                    const worldX = startX + (j * SEGMENT_SIZE);
                    const h = getRawHeight(worldX, worldZ);
                    posAttr.setY(vIdx, h);
                    const biome = getBiomeData(worldX, worldZ, h);
                    let r = biome.r; let g = biome.g; let b = biome.b;
                    const n = Math.random() * 0.05;
                    colAttr.setXYZ(vIdx, r+n, g+n, b+n);
                    vIdx++;
                }
            }
            geo.computeVertexNormals();
            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            scene.add(terrain);
        }

        // --- PLAYER ---
        const charParts = {};
        function createHuman() {
            const group = new THREE.Group();
            const suitMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.5 });
            const padMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 }); 
            const tankMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.3, metalness: 0.6 }); 

            const bodyOffsetZ = 0.05; 

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.65, 0.3), suitMat);
            torso.position.set(0, 1.0, bodyOffsetZ); torso.castShadow = true; group.add(torso);
            const chestPlate = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.3, 0.05), padMat);
            chestPlate.position.set(0, 1.1, bodyOffsetZ - 0.16); group.add(chestPlate);
            const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.6), tankMat);
            tank.rotation.z = Math.PI / 2; tank.rotation.y = Math.PI / 2;
            tank.position.set(0, 1.1, bodyOffsetZ + 0.2); tank.castShadow = true; group.add(tank);

            const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.25), suitMat); leftLeg.geometry.translate(0, -0.4, 0);
            leftLeg.position.set(-0.13, 0.7, bodyOffsetZ); leftLeg.castShadow = true; group.add(leftLeg); charParts.leftLeg = leftLeg;
            const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.25), suitMat); rightLeg.geometry.translate(0, -0.4, 0);
            rightLeg.position.set(0.13, 0.7, bodyOffsetZ); rightLeg.castShadow = true; group.add(rightLeg); charParts.rightLeg = rightLeg;

            const lBoot = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.2, 0.35), padMat); lBoot.position.set(0, -0.8, -0.05); leftLeg.add(lBoot);
            const rBoot = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.2, 0.35), padMat); rBoot.position.set(0, -0.8, -0.05); rightLeg.add(rBoot);
            
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.75, 0.15), suitMat); leftArm.geometry.translate(0, -0.3, 0);
            leftArm.position.set(-0.35, 1.35, bodyOffsetZ); leftArm.rotation.z = 0.1; leftArm.castShadow = true; group.add(leftArm); charParts.leftArm = leftArm;
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.75, 0.15), suitMat); rightArm.geometry.translate(0, -0.3, 0);
            rightArm.position.set(0.35, 1.35, bodyOffsetZ); rightArm.rotation.z = -0.1; rightArm.castShadow = true; group.add(rightArm); charParts.rightArm = rightArm;

            const lGlove = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.2, 0.16), padMat); lGlove.position.set(0, -0.7, 0); leftArm.add(lGlove);
            const rGlove = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.2, 0.16), padMat); rGlove.position.set(0, -0.7, 0); rightArm.add(rGlove);

            scene.add(group);
            return group;
        }
        const playerMesh = createHuman();

        // --- ANIMALS ---
        const animals = [];
        const cowGeo = new THREE.BoxGeometry(1.4, 1.1, 2.0);
        const cowMat = new THREE.MeshStandardMaterial({ color: 0x885533 });
        const cowHead = new THREE.BoxGeometry(0.7, 0.7, 0.9);
        
        const rabbitGeo = new THREE.BoxGeometry(0.4, 0.4, 0.5);
        const rabbitMat = new THREE.MeshStandardMaterial({ color: 0xdddddd });

        function spawnAnimals() {
            // Bio-Cows
            for(let i=0; i<40; i++) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(cowGeo, cowMat);
                body.position.y = 1.0; body.castShadow = true; group.add(body);
                const head = new THREE.Mesh(cowHead, cowMat);
                head.position.set(0, 1.8, -1.3); group.add(head);
                
                const angle = Math.random() * Math.PI * 2;
                const r = 200 + Math.random() * 2000;
                group.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
                scene.add(group);
                animals.push({ mesh: group, type: 'cow', dir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(), timer: 0 });
            }
            // Space Rabbits
            for(let i=0; i<50; i++) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(rabbitGeo, rabbitMat);
                body.position.y = 0.2; body.castShadow = true; group.add(body);
                const ears = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), rabbitMat);
                ears.position.set(0, 0.5, -0.1); group.add(ears);

                const angle = Math.random() * Math.PI * 2;
                const r = 200 + Math.random() * 2000;
                group.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
                scene.add(group);
                animals.push({ mesh: group, type: 'rabbit', dir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(), timer: 0 });
            }
        }

        // --- VEGETATION ---
        const treeCount = 28000; const bushCount = 45000; 
        const foliageGeo = new THREE.ConeGeometry(9, 16, 6); foliageGeo.translate(0, 16, 0);
        const trunkGeo = new THREE.CylinderGeometry(1.0, 1.4, 16, 5); trunkGeo.translate(0, 8, 0);
        const foliageMat = new THREE.MeshStandardMaterial({ color: 0x225522, roughness: 0.9, flatShading: true }); // Greener
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5a4d3b, roughness: 1.0, flatShading: true });
        const foliageMesh = new THREE.InstancedMesh(foliageGeo, foliageMat, treeCount);
        const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
        
        // Huge Alien Mushrooms
        const mushStemGeo = new THREE.CylinderGeometry(1, 1.5, 10, 6); mushStemGeo.translate(0, 5, 0);
        const mushCapGeo = new THREE.ConeGeometry(5, 4, 8); mushCapGeo.translate(0, 12, 0);
        const mushMat = new THREE.MeshStandardMaterial({ color: 0xaa3333, roughness: 0.8 });
        const mushStemMat = new THREE.MeshStandardMaterial({ color: 0xddccaa });
        const mushStemMesh = new THREE.InstancedMesh(mushStemGeo, mushStemMat, 8000);
        const mushCapMesh = new THREE.InstancedMesh(mushCapGeo, mushMat, 8000);

        // Grass
        const grassGeo = new THREE.PlaneGeometry(3, 3);
        const grassMat = new THREE.MeshBasicMaterial({ color: 0x33aa33, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, 50000);

        const rockGeo = new THREE.DodecahedronGeometry(3, 0); 
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
        const rockMesh = new THREE.InstancedMesh(rockGeo, rockMat, 10000);

        const bushGeo = new THREE.DodecahedronGeometry(1.5, 0); bushGeo.translate(0, 1.0, 0);
        const bushMat = new THREE.MeshStandardMaterial({ color: 0x226622, roughness: 1.0, flatShading: true });
        const bushMesh = new THREE.InstancedMesh(bushGeo, bushMat, bushCount);
        
        const dummy = new THREE.Object3D();
        const collisionGrid = {}; 

        function addToGrid(x, z, r) {
            const key = `${Math.floor(x/200)},${Math.floor(z/200)}`;
            if(!collisionGrid[key]) collisionGrid[key] = []; collisionGrid[key].push({x, z, r});
        }

        function isPositionFree(px, pz, radiusCheck) {
            const cx = Math.floor(px/200); const cz = Math.floor(pz/200);
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    const cell = collisionGrid[`${cx+i},${cz+j}`];
                    if(cell) for(let k=0; k<cell.length; k++) {
                        const dx = px - cell[k].x; const dz = pz - cell[k].z;
                        if((dx*dx + dz*dz) < (radiusCheck + cell[k].r)**2) return false;
                    }
                }
            }
            return true;
        }

        function plantVegetation() {
            let tIdx = 0; let mIdx = 0; let gIdx = 0; let rIdx = 0;
            let attempts = 0;
            const loopMax = 150000; // Safety break

            // Trees & Mushrooms
            while((tIdx < treeCount || mIdx < 8000) && attempts < loopMax) {
                attempts++;
                const angle = Math.random() * Math.PI * 2; 
                const r = 100 + Math.random() * 14500; 
                const tx = Math.cos(angle) * r; const tz = Math.sin(angle) * r;
                const y = getMeshHeight(tx, tz);
                const biome = getBiomeData(tx, tz, y);
                
                if(y > -10 && isPositionFree(tx, tz, 10)) {
                    if (tIdx < treeCount && (biome.type === 'FOREST' || (biome.type === 'GRASSLAND' && Math.random() > 0.7))) {
                        dummy.position.set(tx, y, tz);
                        const s = 0.8 + Math.random() * 1.5; dummy.scale.set(s,s,s);
                        dummy.updateMatrix();
                        foliageMesh.setMatrixAt(tIdx, dummy.matrix); trunkMesh.setMatrixAt(tIdx, dummy.matrix);
                        addToGrid(tx, tz, 2.0); 
                        tIdx++;
                    } else if (mIdx < 8000 && biome.type === 'FOREST' && Math.random() > 0.5) {
                        dummy.position.set(tx, y, tz);
                        const s = 0.5 + Math.random() * 1.5; dummy.scale.set(s,s,s);
                        dummy.updateMatrix();
                        mushStemMesh.setMatrixAt(mIdx, dummy.matrix); mushCapMesh.setMatrixAt(mIdx, dummy.matrix);
                        addToGrid(tx, tz, 1.5);
                        mIdx++;
                    }
                }
            }
            foliageMesh.count = tIdx; trunkMesh.count = tIdx;
            mushStemMesh.count = mIdx; mushCapMesh.count = mIdx;
            scene.add(foliageMesh); scene.add(trunkMesh);
            scene.add(mushStemMesh); scene.add(mushCapMesh);

            // Bushes & Grass & Rocks
            let bIdx = 0;
            for(let i=0; i<60000; i++) { // Shared loop for scatter
                const angle = Math.random() * Math.PI * 2; 
                const r = 120 + Math.random() * 14500; 
                const bx = Math.cos(angle) * r; const bz = Math.sin(angle) * r;
                const y = getMeshHeight(bx, bz);
                const biome = getBiomeData(bx, bz, y);

                if(y > -10) {
                    if(bIdx < bushCount && biome.type !== 'SNOW') {
                        dummy.position.set(bx, y, bz);
                        const s = 1.0 + Math.random() * 2.0; dummy.scale.set(s,s,s);
                        dummy.updateMatrix();
                        bushMesh.setMatrixAt(bIdx, dummy.matrix); bIdx++;
                    }
                    if(gIdx < 50000 && biome.type === 'GRASSLAND') {
                        dummy.position.set(bx, y+1.5, bz);
                        dummy.rotation.set(0, Math.random()*3, 0);
                        dummy.updateMatrix();
                        grassMesh.setMatrixAt(gIdx, dummy.matrix); gIdx++;
                    }
                    if(rIdx < 10000 && (biome.type === 'ROCKY_SLOPES' || biome.type === 'MOUNTAIN')) {
                        dummy.position.set(bx, y, bz);
                        const s = 1.0 + Math.random() * 4.0; dummy.scale.set(s,s,s);
                        dummy.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
                        dummy.updateMatrix();
                        rockMesh.setMatrixAt(rIdx, dummy.matrix); rIdx++;
                    }
                }
            }
            bushMesh.count = bIdx; grassMesh.count = gIdx; rockMesh.count = rIdx;
            scene.add(bushMesh); scene.add(grassMesh); scene.add(rockMesh);
        }
        
        function checkTreeCollision(px, pz) {
            const cx = Math.floor(px/200); const cz = Math.floor(pz/200);
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    const cell = collisionGrid[`${cx+i},${cz+j}`];
                    if(cell) for(let k=0; k<cell.length; k++) {
                        if((px - cell[k].x)**2 + (pz - cell[k].z)**2 < (3.5)**2) return true;
                    }
                }
            }
            return false;
        }

        // --- STATE ---
        const player = { x: 0, z: 0, speed: 0, angle: 0, pitch: 0, y: 0, velocityY: 0, isGrounded: true, stamina: 100, isClimbing: false };
        const keys = { w:0, s:0, a:0, d:0, shift:0, space: 0, f: 0 };
        let lastSpacePress = false; let animationTime = 0; let fPressed = false;
        let hasPointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
        let isLocked = false; let isMouseDown = false;
        let btnUp = false; let btnDown = false;
        let timeOfDay = 0.5; // Start at NOON

        window.addEventListener('keydown', e => {
            if(e.code === 'KeyW') keys.w = 1; if(e.code === 'KeyS') keys.s = 1;
            if(e.code === 'KeyA') keys.a = 1; if(e.code === 'KeyD') keys.d = 1;
            if(e.code === 'ShiftLeft') keys.shift = 1; if(e.code === 'Space') keys.space = 1;
            if(e.code === 'ArrowUp') keys.up = 1; if(e.code === 'ArrowDown') keys.down = 1;
            if(e.code === 'KeyF' && !fPressed) { fPressed = true; spotLight.intensity = spotLight.intensity > 0 ? 0 : 2; }
        });
        window.addEventListener('keyup', e => {
            if(e.code === 'KeyW') keys.w = 0; if(e.code === 'KeyS') keys.s = 0;
            if(e.code === 'KeyA') keys.a = 0; if(e.code === 'KeyD') keys.d = 0;
            if(e.code === 'ShiftLeft') keys.shift = 0; if(e.code === 'Space') keys.space = 0; 
            if(e.code === 'ArrowUp') keys.up = 0; if(e.code === 'ArrowDown') keys.down = 0;
            if(e.code === 'KeyF') fPressed = false;
            lastSpacePress = false;
        });

        const bUp = document.getElementById('btn-up'); const bDown = document.getElementById('btn-down');
        bUp.addEventListener('mousedown', () => btnUp = true); bUp.addEventListener('mouseup', () => btnUp = false);
        bUp.addEventListener('touchstart', (e) => { e.preventDefault(); btnUp = true; }); bUp.addEventListener('touchend', (e) => { e.preventDefault(); btnUp = false; });
        bDown.addEventListener('mousedown', () => btnDown = true); bDown.addEventListener('mouseup', () => btnDown = false);
        bDown.addEventListener('touchstart', (e) => { e.preventDefault(); btnDown = true; }); bDown.addEventListener('touchend', (e) => { e.preventDefault(); btnDown = false; });

        document.addEventListener('mousedown', (e) => { if(e.target.classList.contains('look-btn')) return; isMouseDown = true; });
        document.addEventListener('mouseup', () => { isMouseDown = false; });
        document.addEventListener('pointerlockchange', () => { isLocked = (document.pointerLockElement === document.body); });
        document.addEventListener('click', (e) => { 
            if(e.target.classList.contains('look-btn')) return;
            if(gameActive && hasPointerLock && !isLocked) try { document.body.requestPointerLock(); } catch(e){} 
        });

        document.addEventListener('mousemove', (e) => {
            if (!gameActive) return;
            if (isLocked || isMouseDown) {
                player.angle -= e.movementX * 0.002;
                player.pitch -= e.movementY * 0.003; 
                const maxDown = -Math.PI / 2 + 0.1; const maxUp = Math.PI / 2.2; 
                if(player.pitch > maxUp) player.pitch = maxUp; if(player.pitch < maxDown) player.pitch = maxDown;
            }
        });

        // Ensure startGame is accessible globally
        window.startGame = function() {
            if(hasPointerLock) { try { document.body.requestPointerLock(); } catch(e) {} }
            document.getElementById('loading').style.display = 'block';
            setTimeout(() => {
                generateTerrain();
                plantVegetation();
                spawnAnimals();
                document.getElementById('start-screen').style.display = 'none';
                player.x = 0; player.z = 0; player.y = getMeshHeight(0,0);
                gameActive = true; animate();
            }, 100);
        };

        function updateDayNight() {
            timeOfDay += 0.000007; 
            if(timeOfDay > 1) timeOfDay = 0;
            
            const phi = (timeOfDay + 0.25) * Math.PI * 2; 
            const r = 10000;
            sunLight.position.set(r * Math.cos(phi), r * Math.sin(phi), 0);
            sunSphere.position.copy(sunLight.position);

            const isDay = timeOfDay > 0.25 && timeOfDay < 0.75;
            const isSunset = (timeOfDay > 0.2 && timeOfDay < 0.25) || (timeOfDay > 0.75 && timeOfDay < 0.8);
            
            let skyHex = 0x000000;
            let fogHex = 0x000000;
            let sunInt = 0;
            let hemiInt = 0;

            if(isDay) {
                // BRIGHTER DAY SETTINGS
                skyHex = 0x88ccff; fogHex = 0xbbeeff; sunInt = 2.2; hemiInt = 0.8;
            } else if (isSunset) {
                skyHex = 0xff9944; fogHex = 0xffaa66; sunInt = 0.8; hemiInt = 0.3;
            } else {
                skyHex = 0x000510; fogHex = 0x000510; sunInt = 0.0; hemiInt = 0.05;
            }

            scene.background.lerp(new THREE.Color(skyHex), 0.01);
            fog.color.lerp(new THREE.Color(fogHex), 0.01);
            sunLight.intensity = THREE.MathUtils.lerp(sunLight.intensity, sunInt, 0.01);
            hemiLight.intensity = THREE.MathUtils.lerp(hemiLight.intensity, hemiInt, 0.01);

            // Stars fade
            const starTarget = (sunInt > 0.2) ? 0 : 0.8;
            starMat.opacity = THREE.MathUtils.lerp(starMat.opacity, starTarget, 0.01);

            const hrs = Math.floor(timeOfDay * 24);
            const mins = Math.floor((timeOfDay * 24 * 60) % 60);
            document.getElementById('time-disp').innerText = `${hrs.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}`;
        }

        function updateAnimals() {
            for(let i=0; i<animals.length; i++) {
                const anim = animals[i];
                anim.timer++;
                if(anim.timer > 100 + Math.random()*200) { 
                    anim.dir.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                    anim.timer = 0;
                }
                const speed = (anim.type === 'rabbit') ? 0.08 : 0.03;
                anim.mesh.position.addScaledVector(anim.dir, speed); 
                
                // Rabbit hop
                let yOffset = 0;
                if(anim.type === 'rabbit') {
                    yOffset = Math.abs(Math.sin(Date.now() * 0.01)) * 0.5;
                }

                const h = getMeshHeight(anim.mesh.position.x, anim.mesh.position.z);
                anim.mesh.position.y = h + yOffset + ((anim.type==='rabbit')?0.2:1.0);
                anim.mesh.lookAt(anim.mesh.position.x + anim.dir.x, h + yOffset, anim.mesh.position.z + anim.dir.z);
            }
        }

        function animate() {
            requestAnimationFrame(animate); if(!gameActive) return;
            
            updateDayNight();
            updateAnimals();

            if(keys.up || btnUp) player.pitch += 0.03;
            if(keys.down || btnDown) player.pitch -= 0.03;
            const maxDown = -Math.PI / 2 + 0.1; const maxUp = Math.PI / 2.2; 
            if(player.pitch > maxUp) player.pitch = maxUp; if(player.pitch < maxDown) player.pitch = maxDown;

            const normal = getSurfaceNormal(player.x, player.z);
            const slopePercent = Math.tan(Math.acos(normal.y)) * 100;
            let isTooSteep = (slopePercent > 70);
            let isClimbing = (slopePercent > 35 && slopePercent <= 70);
            player.isClimbing = isClimbing;

            const WALK_SPEED = 0.15; const SPRINT_SPEED = 0.35; const CLIMB_SPEED = 0.06; const GRAVITY = 0.02;
            const isMoving = (keys.w || keys.s || keys.a || keys.d);
            let isSprinting = false;

            if (keys.shift && isMoving && player.stamina > 0 && !isClimbing) {
                isSprinting = true; player.stamina -= 0.3;
            } else {
                if (isMoving) player.stamina += 0.1; else player.stamina += 0.3;
            }
            if(player.stamina < 0) player.stamina = 0; if(player.stamina > 100) player.stamina = 100;
            document.getElementById('stamina-bar').style.width = player.stamina + "%";

            document.getElementById('alt-disp').innerText = Math.round(player.y) + "m";
            document.getElementById('slope-disp').innerText = Math.round(slopePercent) + "%";
            document.getElementById('slope-disp').className = "stat-val " + (isTooSteep ? "danger" : (isClimbing ? "climb" : ""));
            const biomeInfo = getBiomeData(player.x, player.z, player.y);
            document.getElementById('biome-disp').innerText = biomeInfo.type;

            let dx = 0, dz = 0;
            let maxSpeed = isClimbing ? CLIMB_SPEED : (isSprinting ? SPRINT_SPEED : WALK_SPEED);
            
            if (isLocked || isMouseDown) {
                const fwdX = Math.sin(player.angle); const fwdZ = Math.cos(player.angle);
                const rightX = Math.sin(player.angle - Math.PI/2); const rightZ = Math.cos(player.angle - Math.PI/2);
                if (keys.w) { dx -= fwdX; dz -= fwdZ; } 
                if (keys.s) { dx += fwdX; dz += fwdZ; }
                if (keys.a) { dx -= rightX; dz -= rightZ; } 
                if (keys.d) { dx += rightX; dz += rightZ; } 
            } else {
                if (keys.a) player.angle += 0.04; if (keys.d) player.angle -= 0.04;
                const fwdX = Math.sin(player.angle); const fwdZ = Math.cos(player.angle);
                if (keys.w) { dx -= fwdX; dz -= fwdZ; }
                if (keys.s) { dx += fwdX; dz += fwdZ; }
            }

            if (dx !== 0 || dz !== 0) {
                const len = Math.sqrt(dx*dx + dz*dz);
                dx = (dx/len) * maxSpeed; dz = (dz/len) * maxSpeed;
            }
            if (isTooSteep) { dx += normal.x * 0.2; dz += normal.z * 0.2; }
            player.speed = THREE.MathUtils.lerp(player.speed, Math.sqrt(dx*dx + dz*dz), 0.1);
            
            const groundY = getMeshHeight(player.x, player.z);
            player.isGrounded = (player.y <= groundY + 0.1);
            if (!player.isGrounded) {
                player.velocityY -= GRAVITY;
            } else {
                player.velocityY = Math.max(0, player.velocityY);
                if (keys.space && !lastSpacePress && player.stamina > 10 && !isClimbing && !isTooSteep) {
                    player.velocityY = 0.4; player.isGrounded = false; player.stamina -= 10; lastSpacePress = true;
                }
            }
            player.y += player.velocityY;
            
            const newX = player.x + dx; 
            const newZ = player.z + dz;

            // --- COLLISION CHECKS ---
            if (!checkTreeCollision(newX, newZ)) {
                player.x = newX;
                player.z = newZ;
            } else {
                // Wall sliding: try moving just X or just Z
                if (!checkTreeCollision(player.x, newZ)) player.z = newZ;
                else if (!checkTreeCollision(newX, player.z)) player.x = newX;
            }

            // --- GROUND CLAMPING ---
            const terrainHeight = getMeshHeight(player.x, player.z);
            if (player.y < terrainHeight) {
                player.y = terrainHeight;
                player.velocityY = 0;
                player.isGrounded = true;
            }

            // --- ANIMATION & CAMERA ---
            if (isMoving && player.isGrounded) {
                animationTime += (isSprinting ? 0.3 : 0.15);
            }
            
            // Head Bob
            const bobOffset = Math.sin(animationTime) * 0.08;
            const swayOffset = Math.cos(animationTime * 0.5) * 0.04;
            
            // Update Camera
            camera.position.set(player.x + swayOffset, player.y + 1.7 + bobOffset, player.z);
            camera.rotation.x = player.pitch;
            camera.rotation.y = player.angle;

            // Update Player Mesh (Shadow Caster)
            playerMesh.position.set(player.x, player.y, player.z);
            playerMesh.rotation.y = player.angle + Math.PI; // Face forward
            
            // Animate Limbs
            if (charParts.leftLeg) {
                const walkCycle = Math.sin(animationTime);
                charParts.leftLeg.rotation.x = walkCycle * 0.5;
                charParts.rightLeg.rotation.x = -walkCycle * 0.5;
                charParts.leftArm.rotation.x = -walkCycle * 0.5;
                charParts.rightArm.rotation.x = walkCycle * 0.5;
            }

            // Update Flashlight
            spotLight.position.copy(camera.position);
            // Calculate target based on look angles
            const lookDir = new THREE.Vector3(0, 0, -1);
            lookDir.applyEuler(camera.rotation);
            spotLight.target.position.copy(camera.position).add(lookDir);
            spotLight.target.updateMatrixWorld();

            // --- RENDER ---
            composer.render();
        }
    </script>
</body>
</html>
